import { createContext, useContext, useRef, useEffect, memo, useState, createRef, createElement, Fragment, useCallback, Children, isValidElement, cloneElement, useMemo } from 'react';
import invariant from 'invariant';
import { Clusterer } from '@react-google-maps/marker-clusterer';
import { createPortal } from 'react-dom';
import { InfoBox as InfoBox$1 } from '@react-google-maps/infobox';

var MapContext =
/*#__PURE__*/
createContext(null);
function useGoogleMap() {
  !!!useContext ? process.env.NODE_ENV !== "production" ? invariant(false, 'useGoogleMap is React hook and requires React version 16.8+') : invariant(false) : void 0;
  var map = useContext(MapContext);
  !!!map ? process.env.NODE_ENV !== "production" ? invariant(false, 'useGoogleMap needs a GoogleMap available up in the tree') : invariant(false) : void 0;
  return map;
}

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any
var reduce = function reduce(obj, fn, acc) {
  return Object.keys(obj).reduce(function reducer(newAcc, key) {
    return fn(newAcc, obj[key], key);
  }, acc);
};

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any
function forEach(obj, fn) {
  Object.keys(obj).forEach(function callbackfn(key) {
    return fn(obj[key], key);
  });
}

/* global google */
function applyUpdaterToNextProps(updaterMap, prevProps, nextProps, instance) {
  var map = {};

  function iter(fn, key) {
    var nextValue = nextProps[key];

    if (nextValue !== prevProps[key]) {
      map[key] = nextValue;
      fn(instance, nextValue);
    }
  }

  forEach(updaterMap, iter);
  return map;
}
function registerEvents(props, instance, eventMap) {
  var registeredList = reduce(eventMap, function reducer(acc, googleEventName, onEventName) {
    if (typeof props[onEventName] === 'function') {
      acc.push(google.maps.event.addListener(instance, googleEventName, props[onEventName]));
    }

    return acc;
  }, []);
  return registeredList;
}

function unregisterEvent(registered) {
  google.maps.event.removeListener(registered);
}

function unregisterEvents(events) {
  if (events === void 0) {
    events = [];
  }

  events.forEach(unregisterEvent);
}
function applyUpdatersToPropsAndRegisterEvents(_ref) {
  var updaterMap = _ref.updaterMap,
      eventMap = _ref.eventMap,
      prevProps = _ref.prevProps,
      nextProps = _ref.nextProps,
      instance = _ref.instance;
  var registeredEvents = registerEvents(nextProps, instance, eventMap);
  applyUpdaterToNextProps(updaterMap, prevProps, nextProps, instance);
  return registeredEvents;
}

function usePrevious(props) {
  var ref = useRef(props);
  useEffect(function effect() {
    ref.current = props;
  }, [props]);
  return ref.current;
}

var eventMap = {
  onDblClick: 'dblclick',
  onDragEnd: 'dragend',
  onDragStart: 'dragstart',
  onMapTypeIdChanged: 'maptypeid_changed',
  onMouseMove: 'mousemove',
  onMouseOut: 'mouseout',
  onMouseOver: 'mouseover',
  onMouseDown: 'mousedown',
  onMouseUp: 'mouseup',
  onRightClick: 'rightclick',
  onTilesLoaded: 'tilesloaded',
  onBoundsChanged: 'bounds_changed',
  onCenterChanged: 'center_changed',
  onClick: 'click',
  onDrag: 'drag',
  onHeadingChanged: 'heading_changed',
  onIdle: 'idle',
  onProjectionChanged: 'projection_changed',
  onResize: 'resize',
  onTiltChanged: 'tilt_changed',
  onZoomChanged: 'zoom_changed'
};
var updaterMap = {
  extraMapTypes: function extraMapTypes(map, extra) {
    extra.forEach(function forEachExtra(it, i) {
      map.mapTypes.set(String(i), it);
    });
  },
  center: function center(map, _center) {
    map.setCenter(_center);
  },
  clickableIcons: function clickableIcons(map, clickable) {
    map.setClickableIcons(clickable);
  },
  heading: function heading(map, _heading) {
    map.setHeading(_heading);
  },
  mapTypeId: function mapTypeId(map, _mapTypeId) {
    map.setMapTypeId(_mapTypeId);
  },
  options: function options(map, _options) {
    map.setOptions(_options);
  },
  streetView: function streetView(map, _streetView) {
    map.setStreetView(_streetView);
  },
  tilt: function tilt(map, _tilt) {
    map.setTilt(_tilt);
  },
  zoom: function zoom(map, _zoom) {
    map.setZoom(_zoom);
  }
};

function GoogleMap(props) {
  var children = props.children,
      options = props.options,
      id = props.id,
      mapContainerStyle = props.mapContainerStyle,
      mapContainerClassName = props.mapContainerClassName,
      onLoad = props.onLoad,
      onUnmount = props.onUnmount;

  var _React$useState = useState(null),
      instance = _React$useState[0],
      setInstance = _React$useState[1];

  var mapRef = createRef();
  var prevProps = usePrevious(props);
  useEffect(function effect() {
    if (instance === null && mapRef.current !== null) {
      setInstance(new google.maps.Map(mapRef.current, options));
    }

    if (instance !== null) {
      if (onLoad) {
        onLoad(instance);
      }
    }

    return function cleanup() {
      if (instance !== null) {
        if (onUnmount) {
          onUnmount(instance);
        }
      }
    };
  }, [instance, options, onLoad, onUnmount, mapRef]);
  useEffect(function effect() {
    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({
      updaterMap: updaterMap,
      eventMap: eventMap,
      prevProps: prevProps,
      nextProps: props,
      instance: instance
    });
    return function cleanup() {
      unregisterEvents(registeredEvents);
    };
  }, [props, instance, prevProps]);
  return createElement("div", {
    id: id,
    ref: mapRef,
    style: mapContainerStyle,
    className: mapContainerClassName
  }, createElement(MapContext.Provider, {
    value: instance
  }, instance !== null ? children : createElement(Fragment, null)));
}

var GoogleMap$1 = /*#__PURE__*/
memo(GoogleMap);

var isBrowser = typeof document !== 'undefined';

function injectScript(_ref) {
  var url = _ref.url,
      id = _ref.id;

  if (!isBrowser) {
    return Promise.reject(new Error('document is undefined'));
  }

  return new Promise(function injectScriptCallback(resolve, reject) {
    var existingScript = document.getElementById(id);
    var windowWithGoogleMap = window;

    if (existingScript) {
      // Same script id/url: keep same script
      var dataStateAttribute = existingScript.getAttribute('data-state');

      if (existingScript.src === url && dataStateAttribute !== 'error') {
        if (dataStateAttribute === 'ready') {
          return resolve(id);
        } else {
          var originalInitMap = windowWithGoogleMap.initMap;
          var originalErrorCallback = existingScript.onerror;

          windowWithGoogleMap.initMap = function initMap() {
            if (originalInitMap) {
              originalInitMap();
            }

            resolve(id);
          };

          existingScript.onerror = function onerror(err) {
            if (originalErrorCallback) {
              originalErrorCallback(err);
            }

            reject(err);
          };
        }
      } // Same script id, but either
      // 1. requested URL is different
      // 2. script failed to load
      else {
          existingScript.remove();
        }
    }

    var script = document.createElement('script');
    script.type = 'text/javascript';
    script.src = url;
    script.id = id;
    script.async = true;

    script.onerror = function onerror(err) {
      script.setAttribute('data-state', 'error');
      reject(err);
    };

    windowWithGoogleMap.initMap = function onload() {
      script.setAttribute('data-state', 'ready');
      resolve(id);
    };

    document.head.appendChild(script);
  })["catch"](function (err) {
    console.error('injectScript error: ', err);
    throw err;
  });
}

var isRobotoStyle = function isRobotoStyle(element) {
  // roboto font download
  if (element.href && element.href.indexOf('https://fonts.googleapis.com/css?family=Roboto') === 0) {
    return true;
  } // roboto style elements


  if (element.tagName.toLowerCase() === 'style' && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  element.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  element.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  element.styleSheet.cssText.replace('\r\n', '').indexOf('.gm-style') === 0) {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    element.styleSheet.cssText = '';
    return true;
  } // roboto style elements for other browsers


  if (element.tagName.toLowerCase() === 'style' && element.innerHTML && element.innerHTML.replace('\r\n', '').indexOf('.gm-style') === 0) {
    element.innerHTML = '';
    return true;
  } // when google tries to add empty style


  if (element.tagName.toLowerCase() === 'style' && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  !element.styleSheet && !element.innerHTML) {
    return true;
  }

  return false;
}; // Preventing the Google Maps library from downloading an extra font


var preventGoogleFonts = function preventGoogleFonts() {
  // we override these methods only for one particular head element
  // default methods for other elements are not affected
  var head = document.getElementsByTagName('head')[0];
  var trueInsertBefore = head.insertBefore.bind(head); // TODO: adding return before reflect solves the TS issue
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore

  head.insertBefore = function insertBefore(newElement, referenceElement) {
    if (!isRobotoStyle(newElement)) {
      Reflect.apply(trueInsertBefore, head, [newElement, referenceElement]);
    }
  };

  var trueAppend = head.appendChild.bind(head); // TODO: adding return before reflect solves the TS issue
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore

  head.appendChild = function appendChild(textNode) {
    if (!isRobotoStyle(textNode)) {
      Reflect.apply(trueAppend, head, [textNode]);
    }
  };
};

function makeLoadScriptUrl(_ref) {
  var googleMapsApiKey = _ref.googleMapsApiKey,
      googleMapsClientId = _ref.googleMapsClientId,
      _ref$version = _ref.version,
      version = _ref$version === void 0 ? 'weekly' : _ref$version,
      language = _ref.language,
      region = _ref.region,
      libraries = _ref.libraries,
      channel = _ref.channel;
  var params = [];
  !(googleMapsApiKey && googleMapsClientId || !(googleMapsApiKey && googleMapsClientId)) ? process.env.NODE_ENV !== "production" ? invariant(false, 'You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time.') : invariant(false) : void 0;

  if (googleMapsApiKey) {
    params.push("key=" + googleMapsApiKey);
  } else if (googleMapsClientId) {
    params.push("client=" + googleMapsClientId);
  }

  if (version) {
    params.push("v=" + version);
  }

  if (language) {
    params.push("language=" + language);
  }

  if (region) {
    params.push("region=" + region);
  }

  if (libraries && libraries.length) {
    params.push("libraries=" + libraries.sort().join(','));
  }

  if (channel) {
    params.push("channel=" + channel);
  }

  params.push('callback=initMap');
  return "https://maps.googleapis.com/maps/api/js?" + params.join('&');
}

var cleaningUp = false;
function DefaultLoadingElement() {
  return createElement("div", null, "Loading...");
}
var defaultLoadScriptProps = {
  id: 'script-loader',
  version: 'weekly'
};

function LoadScript(props) {
  var googleMapsApiKey = props.googleMapsApiKey,
      googleMapsClientId = props.googleMapsClientId,
      children = props.children,
      _props$id = props.id,
      id = _props$id === void 0 ? 'script-loader' : _props$id,
      _props$version = props.version,
      version = _props$version === void 0 ? 'weekly' : _props$version,
      language = props.language,
      region = props.region,
      channel = props.channel,
      libraries = props.libraries,
      loadingElement = props.loadingElement,
      onLoad = props.onLoad,
      onUnmount = props.onUnmount,
      onError = props.onError,
      preventGoogleFontsLoading = props.preventGoogleFontsLoading;
  var prevProps = usePrevious(props);

  var _React$useState = useState(false),
      loaded = _React$useState[0],
      setLoaded = _React$useState[1];

  var check = useRef(null);
  var injectScript$1 = useCallback(function callback() {
    if (preventGoogleFontsLoading) {
      preventGoogleFonts();
    }

    !!!id ? process.env.NODE_ENV !== "production" ? invariant(false, 'LoadScript requires "id" prop to be a string: %s', id) : invariant(false) : void 0;
    var injectScriptOptions = {
      id: id,
      url: makeLoadScriptUrl({
        googleMapsApiKey: googleMapsApiKey,
        googleMapsClientId: googleMapsClientId,
        version: version,
        language: language,
        region: region,
        libraries: libraries,
        channel: channel
      })
    };
    injectScript(injectScriptOptions).then(function onfulfilled() {
      if (onLoad) {
        onLoad();
      }

      setLoaded(true);
      return;
    })["catch"](function onrejected(err) {
      if (onError) {
        onError(err);
      }

      console.error("\n          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (" + (googleMapsApiKey || '-') + ") or Client ID (" + (googleMapsClientId || '-') + ") to <LoadScript />\n          Otherwise it is a Network issue.\n        ");
    });
  }, [googleMapsApiKey, id, version, language, region, channel, libraries, googleMapsClientId, preventGoogleFontsLoading, onError, onLoad]);
  var isCleaningUp = useCallback(function callback() {
    try {
      var promiseCallback = function promiseCallback(resolve) {
        if (!cleaningUp) {
          resolve();
        } else {
          if (isBrowser) {
            var timer = window.setInterval(function interval() {
              if (!cleaningUp) {
                window.clearInterval(timer);
                resolve();
              }
            }, 1);
          }
        }

        return;
      };

      return Promise.resolve(new Promise(promiseCallback));
    } catch (e) {
      return Promise.reject(e);
    }
  }, []);
  var cleanup = useCallback(function callback() {
    cleaningUp = true;
    var script = document.getElementById(id);

    if (script && script.parentNode) {
      script.parentNode.removeChild(script);
    }

    Array.prototype.slice.call(document.getElementsByTagName('script')).filter(function filter(script) {
      return typeof script.src === 'string' && script.src.includes('maps.googleapis');
    }).forEach(function forEach(script) {
      if (script.parentNode) {
        script.parentNode.removeChild(script);
      }
    });
    Array.prototype.slice.call(document.getElementsByTagName('link')).filter(function filter(link) {
      return link.href === 'https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans';
    }).forEach(function forEach(link) {
      if (link.parentNode) {
        link.parentNode.removeChild(link);
      }
    });
    Array.prototype.slice.call(document.getElementsByTagName('style')).filter(function filter(style) {
      return style.innerText !== undefined && style.innerText.length > 0 && style.innerText.includes('.gm-');
    }).forEach(function forEach(style) {
      if (style.parentNode) {
        style.parentNode.removeChild(style);
      }
    });
  }, [id]);
  useEffect(function effect() {
    if (isBrowser) {
      if (window.google && !cleaningUp) {
        console.error('google api is already presented');
        return function cleanup() {
          return;
        };
      }

      isCleaningUp().then(injectScript$1)["catch"](function onrejected(err) {
        console.error('Error at injecting script after cleaning up: ', err);
      });
    }

    return function callback() {
      if (isBrowser) {
        cleanup();

        var timeoutCallback = function timeoutCallback() {
          // eslint-disable-next-line react-hooks/exhaustive-deps
          if (check.current === null) {
            delete window.google;
            cleaningUp = false;
          }
        };

        window.setTimeout(timeoutCallback, 1);

        if (onUnmount) {
          onUnmount();
        }
      }
    };
  }, [cleanup, isCleaningUp, onUnmount, injectScript$1]);
  useEffect(function effect() {
    if (libraries !== prevProps.libraries) {
      console.warn('Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables');
    }

    if (isBrowser && prevProps.language !== language) {
      cleanup();
      setLoaded(false);
      delete window.google;
      injectScript$1();
    }
  }, [cleanup, injectScript$1, language, libraries, prevProps.language, prevProps.libraries]);
  return createElement(Fragment, null, createElement("div", {
    ref: check
  }), loaded ? children : loadingElement || createElement(DefaultLoadingElement, null));
}

var LoadScript$1 = /*#__PURE__*/
memo(LoadScript);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var previouslyLoadedUrl;
function useLoadScript(_ref) {
  var _ref$id = _ref.id,
      id = _ref$id === void 0 ? defaultLoadScriptProps.id : _ref$id,
      _ref$version = _ref.version,
      version = _ref$version === void 0 ? defaultLoadScriptProps.version : _ref$version,
      googleMapsApiKey = _ref.googleMapsApiKey,
      googleMapsClientId = _ref.googleMapsClientId,
      language = _ref.language,
      region = _ref.region,
      libraries = _ref.libraries,
      preventGoogleFontsLoading = _ref.preventGoogleFontsLoading,
      channel = _ref.channel;
  var isMounted = useRef(false);

  var _React$useState = useState(false),
      isLoaded = _React$useState[0],
      setLoaded = _React$useState[1];

  var _React$useState2 = useState(undefined),
      loadError = _React$useState2[0],
      setLoadError = _React$useState2[1];

  useEffect(function trackMountedState() {
    isMounted.current = true;
    return function () {
      isMounted.current = false;
    };
  }, []);
  useEffect(function applyPreventGoogleFonts() {
    if (isBrowser && preventGoogleFontsLoading) {
      preventGoogleFonts();
    }
  }, [preventGoogleFontsLoading]);
  useEffect(function validateLoadedState() {
    if (isLoaded) {
      !!!window.google ? process.env.NODE_ENV !== "production" ? invariant(false, 'useLoadScript was marked as loaded, but window.google is not present. Something went wrong.') : invariant(false) : void 0;
    }
  }, [isLoaded]);
  var url = makeLoadScriptUrl({
    version: version,
    googleMapsApiKey: googleMapsApiKey,
    googleMapsClientId: googleMapsClientId,
    language: language,
    region: region,
    libraries: libraries,
    channel: channel
  });
  useEffect(function loadScriptAndModifyLoadedState() {
    if (!isBrowser) {
      return;
    }

    function setLoadedIfMounted() {
      if (isMounted.current) {
        setLoaded(true);
        previouslyLoadedUrl = url;
      }
    }

    if (window.google && previouslyLoadedUrl === url) {
      setLoadedIfMounted();
      return;
    }

    injectScript({
      id: id,
      url: url
    }).then(setLoadedIfMounted)["catch"](function handleInjectError(err) {
      if (isMounted.current) {
        setLoadError(err);
      }

      console.warn("\n        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (" + (googleMapsApiKey || '-') + ") or Client ID (" + (googleMapsClientId || '-') + ")\n        Otherwise it is a Network issue.\n      ");
      console.error(err);
    });
  }, [id, url, googleMapsApiKey, googleMapsClientId]);
  var prevLibraries = useRef();
  useEffect(function checkPerformance() {
    if (prevLibraries.current && libraries !== prevLibraries.current) {
      console.warn('Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables');
    }

    prevLibraries.current = libraries;
  }, [libraries]);
  return {
    isLoaded: isLoaded,
    loadError: loadError,
    url: url
  };
}

var defaultLoadingElement =
/*#__PURE__*/
createElement(DefaultLoadingElement, null);

function LoadScriptNext(_ref) {
  var loadingElement = _ref.loadingElement,
      onLoad = _ref.onLoad,
      onError = _ref.onError,
      onUnmount = _ref.onUnmount,
      children = _ref.children,
      hookOptions = _objectWithoutPropertiesLoose(_ref, ["loadingElement", "onLoad", "onError", "onUnmount", "children"]);

  var _useLoadScript = useLoadScript(hookOptions),
      isLoaded = _useLoadScript.isLoaded,
      loadError = _useLoadScript.loadError;

  useEffect(function effect() {
    if (isLoaded && typeof onLoad === 'function') {
      onLoad();
    }
  }, [isLoaded, onLoad]);
  useEffect(function effect() {
    if (loadError && typeof onError === 'function') {
      onError(loadError);
    }
  }, [loadError, onError]);
  useEffect(function effect() {
    return function () {
      if (onUnmount) {
        onUnmount();
      }
    };
  }, [onUnmount]);
  return isLoaded ? children : loadingElement || defaultLoadingElement;
}

var LoadScriptNext$1 = /*#__PURE__*/
memo(LoadScriptNext);

var eventMap$1 = {};
var updaterMap$1 = {
  options: function options(instance, _options) {
    instance.setOptions(_options);
  }
};

function TrafficLayer(props) {
  var options = props.options,
      onLoad = props.onLoad,
      onUnmount = props.onUnmount;
  var map = useContext(MapContext);
  var prevProps = usePrevious(props);

  var _React$useState = useState(null),
      instance = _React$useState[0],
      setInstance = _React$useState[1];

  useEffect(function effect() {
    if (map !== null) {
      if (instance === null) {
        setInstance(new google.maps.TrafficLayer(_extends({}, options || {}, {
          map: map
        })));
      }

      if (instance !== null) {
        instance.setMap(map);

        if (onLoad) {
          onLoad(instance);
        }
      }
    }

    return function cleanup() {
      if (instance !== null) {
        if (onUnmount) {
          onUnmount(instance);
        }

        instance.setMap(null);
      }
    };
  }, [instance, map, options, onLoad, onUnmount]);
  useEffect(function effect() {
    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({
      updaterMap: updaterMap$1,
      eventMap: eventMap$1,
      prevProps: prevProps,
      nextProps: props,
      instance: instance
    });
    return function cleanup() {
      unregisterEvents(registeredEvents);
    };
  }, [props, instance, prevProps]);
  return createElement(Fragment, null);
}

var TrafficLayer$1 = /*#__PURE__*/
memo(TrafficLayer);

function BicyclingLayer(_ref) {
  var onLoad = _ref.onLoad,
      onUnmount = _ref.onUnmount;
  var map = useContext(MapContext);

  var _React$useState = useState(null),
      instance = _React$useState[0],
      setInstance = _React$useState[1];

  useEffect(function effect() {
    if (map !== null) {
      if (instance === null) {
        setInstance(new google.maps.BicyclingLayer());
      }

      if (instance !== null) {
        instance.setMap(map);

        if (onLoad) {
          onLoad(instance);
        }
      }
    }

    return function cleanup() {
      if (instance !== null) {
        if (onUnmount) {
          onUnmount(instance);
        }

        instance.setMap(null);
      }
    };
  }, [instance, map, onLoad, onUnmount]);
  return createElement(Fragment, null);
}

var BicyclingLayer$1 = /*#__PURE__*/
memo(BicyclingLayer);

function TransitLayer(props) {
  var onLoad = props.onLoad,
      onUnmount = props.onUnmount;
  var map = useContext(MapContext);

  var _React$useState = useState(null),
      instance = _React$useState[0],
      setInstance = _React$useState[1];

  useEffect(function effect() {
    var newInstance = new google.maps.TransitLayer();
    setInstance(newInstance);
    newInstance.setMap(map);

    if (onLoad) {
      onLoad(newInstance);
    }

    return function cleanup() {
      if (instance !== null) {
        if (onUnmount) {
          onUnmount(instance);
        }

        instance.setMap(null);
      }
    };
  }, [instance, map, onLoad, onUnmount]);
  return createElement(Fragment, null);
}

var TransitLayer$1 = /*#__PURE__*/
memo(TransitLayer);

var eventMap$2 = {
  onCircleComplete: 'circlecomplete',
  onMarkerComplete: 'markercomplete',
  onOverlayComplete: 'overlaycomplete',
  onPolygonComplete: 'polygoncomplete',
  onPolylineComplete: 'polylinecomplete',
  onRectangleComplete: 'rectanglecomplete'
};
var updaterMap$2 = {
  drawingMode: function drawingMode(instance, _drawingMode) {
    instance.setDrawingMode(_drawingMode);
  },
  options: function options(instance, _options) {
    instance.setOptions(_options);
  }
};

function DrawingManager(props) {
  var options = props.options,
      onLoad = props.onLoad,
      onUnmount = props.onUnmount;
  var map = useContext(MapContext);
  var prevProps = usePrevious(props);

  var _React$useState = useState(null),
      instance = _React$useState[0],
      setInstance = _React$useState[1];

  useEffect(function effect() {
    !!!google.maps.drawing ? process.env.NODE_ENV !== "production" ? invariant(false, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing) : invariant(false) : void 0;

    if (map !== null) {
      if (instance === null) {
        setInstance(new google.maps.drawing.DrawingManager(_extends({}, options || {}, {
          map: map
        })));
      }

      if (instance !== null) {
        instance.setMap(map);

        if (onLoad) {
          onLoad(instance);
        }
      }
    }

    return function cleanup() {
      if (instance !== null) {
        if (onUnmount) {
          onUnmount(instance);
        }

        instance.setMap(null);
      }
    };
  }, [instance, map, options, onLoad, onUnmount]);
  useEffect(function effect() {
    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({
      updaterMap: updaterMap$2,
      eventMap: eventMap$2,
      prevProps: prevProps,
      nextProps: props,
      instance: instance
    });
    return function cleanup() {
      unregisterEvents(registeredEvents);
    };
  }, [props, instance, prevProps]);
  return createElement(Fragment, null);
}

var DrawingManager$1 = /*#__PURE__*/
memo(DrawingManager);

var eventMap$3 = {
  onAnimationChanged: 'animation_changed',
  onClick: 'click',
  onClickableChanged: 'clickable_changed',
  onCursorChanged: 'cursor_changed',
  onDblClick: 'dblclick',
  onDrag: 'drag',
  onDragEnd: 'dragend',
  onDraggableChanged: 'draggable_changed',
  onDragStart: 'dragstart',
  onFlatChanged: 'flat_changed',
  onIconChanged: 'icon_changed',
  onMouseDown: 'mousedown',
  onMouseOut: 'mouseout',
  onMouseOver: 'mouseover',
  onMouseUp: 'mouseup',
  onPositionChanged: 'position_changed',
  onRightClick: 'rightclick',
  onShapeChanged: 'shape_changed',
  onTitleChanged: 'title_changed',
  onVisibleChanged: 'visible_changed',
  onZindexChanged: 'zindex_changed'
};
var updaterMap$3 = {
  animation: function animation(instance, _animation) {
    instance.setAnimation(_animation);
  },
  clickable: function clickable(instance, _clickable) {
    instance.setClickable(_clickable);
  },
  cursor: function cursor(instance, _cursor) {
    instance.setCursor(_cursor);
  },
  draggable: function draggable(instance, _draggable) {
    instance.setDraggable(_draggable);
  },
  icon: function icon(instance, _icon) {
    instance.setIcon(_icon);
  },
  label: function label(instance, _label) {
    instance.setLabel(_label);
  },
  map: function map(instance, _map) {
    instance.setMap(_map);
  },
  opacity: function opacity(instance, _opacity) {
    instance.setOpacity(_opacity);
  },
  options: function options(instance, _options) {
    instance.setOptions(_options);
  },
  position: function position(instance, _position) {
    instance.setPosition(_position);
  },
  shape: function shape(instance, _shape) {
    instance.setShape(_shape);
  },
  title: function title(instance, _title) {
    instance.setTitle(_title);
  },
  visible: function visible(instance, _visible) {
    instance.setVisible(_visible);
  },
  zIndex: function zIndex(instance, _zIndex) {
    instance.setZIndex(_zIndex);
  }
};

function Marker(props) {
  var children = props.children,
      options = props.options,
      position = props.position,
      clusterer = props.clusterer,
      noClustererRedraw = props.noClustererRedraw,
      onLoad = props.onLoad,
      onUnmount = props.onUnmount;
  var map = useContext(MapContext);
  var prevProps = usePrevious(props);

  var _React$useState = useState(null),
      instance = _React$useState[0],
      setInstance = _React$useState[1];

  useEffect(function effect() {
    if (map !== null) {
      if (instance === null) {
        var marker = new google.maps.Marker(_extends({}, options || {}, {}, clusterer ? {} : {
          map: map
        }, {
          position: position
        }));

        if (clusterer) {
          clusterer.addMarker(marker, !!noClustererRedraw);
        } else {
          marker.setMap(map);
        }

        setInstance(marker);
      }

      if (instance !== null) {
        instance.setMap(map);

        if (onLoad) {
          onLoad(instance);
        }
      }
    }

    return function cleanup() {
      if (instance !== null) {
        if (onUnmount) {
          onUnmount(instance);
        }

        if (clusterer) {
          clusterer.removeMarker(instance, !!noClustererRedraw);
        } else {
          instance && instance.setMap(null);
        }
      }
    };
  }, [instance, map, options, clusterer, noClustererRedraw, position, onLoad, onUnmount]);
  useEffect(function effect() {
    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({
      updaterMap: updaterMap$3,
      eventMap: eventMap$3,
      prevProps: prevProps,
      nextProps: props,
      instance: instance
    });
    return function cleanup() {
      unregisterEvents(registeredEvents);
    };
  }, [props, instance, prevProps]);

  if (children) {
    return createElement(Fragment, null, Children.map(children, function mapper(child) {
      if (!isValidElement(child)) {
        return child;
      }

      var elementChild = child;
      return cloneElement(elementChild, {
        anchor: instance
      });
    }));
  } else {
    return createElement(Fragment, null);
  }
}

var Marker$1 = /*#__PURE__*/
memo(Marker);

var eventMap$4 = {
  onClick: 'click',
  onClusteringBegin: 'clusteringbegin',
  onClusteringEnd: 'clusteringend',
  onMouseOut: 'mouseout',
  onMouseOver: 'mouseover'
};
var updaterMap$4 = {
  averageCenter: function averageCenter(instance, _averageCenter) {
    instance.setAverageCenter(_averageCenter);
  },
  batchSizeIE: function batchSizeIE(instance, _batchSizeIE) {
    instance.setBatchSizeIE(_batchSizeIE);
  },
  calculator: function calculator(instance, _calculator) {
    instance.setCalculator(_calculator);
  },
  clusterClass: function clusterClass(instance, _clusterClass) {
    instance.setClusterClass(_clusterClass);
  },
  enableRetinaIcons: function enableRetinaIcons(instance, _enableRetinaIcons) {
    instance.setEnableRetinaIcons(_enableRetinaIcons);
  },
  gridSize: function gridSize(instance, _gridSize) {
    instance.setGridSize(_gridSize);
  },
  ignoreHidden: function ignoreHidden(instance, _ignoreHidden) {
    instance.setIgnoreHidden(_ignoreHidden);
  },
  imageExtension: function imageExtension(instance, _imageExtension) {
    instance.setImageExtension(_imageExtension);
  },
  imagePath: function imagePath(instance, _imagePath) {
    instance.setImagePath(_imagePath);
  },
  imageSizes: function imageSizes(instance, _imageSizes) {
    instance.setImageSizes(_imageSizes);
  },
  maxZoom: function maxZoom(instance, _maxZoom) {
    instance.setMaxZoom(_maxZoom);
  },
  minimumClusterSize: function minimumClusterSize(instance, _minimumClusterSize) {
    instance.setMinimumClusterSize(_minimumClusterSize);
  },
  styles: function styles(instance, _styles) {
    instance.setStyles(_styles);
  },
  title: function title(instance, _title) {
    instance.setTitle(_title);
  },
  zoomOnClick: function zoomOnClick(instance, _zoomOnClick) {
    instance.setZoomOnClick(_zoomOnClick);
  }
};

function ClustererComponent(props) {
  var children = props.children,
      options = props.options,
      onLoad = props.onLoad,
      onUnmount = props.onUnmount;
  var map = useContext(MapContext);
  var prevProps = usePrevious(props);

  var _React$useState = useState(null),
      instance = _React$useState[0],
      setInstance = _React$useState[1];

  useEffect(function effect() {
    if (map !== null) {
      if (instance === null) {
        setInstance(new Clusterer(map, [], options));
      }

      if (instance !== null) {
        if (onLoad) {
          onLoad(instance);
        }
      }
    }

    return function cleanup() {
      if (instance !== null) {
        if (onUnmount) {
          onUnmount(instance);
        } // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore


        instance.setMap(null);
      }
    };
  }, [instance, map, options, onLoad, onUnmount]);
  useEffect(function effect() {
    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({
      updaterMap: updaterMap$4,
      eventMap: eventMap$4,
      prevProps: prevProps,
      nextProps: props,
      instance: instance
    });
    return function cleanup() {
      unregisterEvents(registeredEvents);
    };
  }, [props, instance, prevProps]);
  return instance !== null ? createElement(Fragment, null, children(instance)) : createElement(Fragment, null);
}

var MarkerClusterer = /*#__PURE__*/
memo(ClustererComponent);

var eventMap$5 = {
  onCloseClick: 'closeclick',
  onContentChanged: 'content_changed',
  onDomReady: 'domready',
  onPositionChanged: 'position_changed',
  onZindexChanged: 'zindex_changed'
};
var updaterMap$5 = {
  options: function options(instance, _options) {
    instance.setOptions(_options);
  },
  position: function position(instance, _position) {
    if (_position instanceof google.maps.LatLng) {
      instance.setPosition(_position);
    } else {
      instance.setPosition(new google.maps.LatLng(_position.lat, _position.lng));
    }
  },
  visible: function visible(instance, _visible) {
    instance.setVisible(_visible);
  },
  zIndex: function zIndex(instance, _zIndex) {
    instance.setZIndex(_zIndex);
  }
};

function InfoBoxComponent(props) {
  var children = props.children,
      options = props.options,
      anchor = props.anchor,
      onLoad = props.onLoad,
      onUnmount = props.onUnmount;

  var _ref = options || {},
      position = _ref.position,
      infoBoxOptions = _objectWithoutPropertiesLoose(_ref, ["position"]);

  var map = useContext(MapContext);
  var prevProps = usePrevious(props);
  var containerElementRef = useRef(null);

  var _React$useState = useState(null),
      instance = _React$useState[0],
      setInstance = _React$useState[1];

  useEffect(function effect() {
    if (map !== null) {
      if (instance === null) {
        var positionLatLng;

        if (position && !(position instanceof google.maps.LatLng)) {
          positionLatLng = new google.maps.LatLng(position.lat, position.lng);
        }

        containerElementRef.current = document.createElement('div');
        var infoBox = new InfoBox$1(_extends({}, infoBoxOptions, {}, positionLatLng ? {
          position: positionLatLng
        } : {}));
        setInstance(infoBox);
      }

      if (instance !== null && containerElementRef.current !== null) {
        instance.setContent(containerElementRef.current);

        if (anchor) {
          instance.open(map, anchor);
        } else if (instance.getPosition()) {
          instance.open(map);
        } else {
           process.env.NODE_ENV !== "production" ? invariant(false, 'You must provide either an anchor or a position prop for <InfoBox>.') : invariant(false) ;
        }

        if (onLoad) {
          onLoad(instance);
        }
      }
    }

    return function cleanup() {
      if (instance !== null) {
        if (onUnmount) {
          onUnmount(instance);
        }

        instance.close();
      }
    };
  }, [instance, map, options, onLoad, onUnmount, anchor, containerElementRef, infoBoxOptions, position]);
  useEffect(function effect() {
    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({
      updaterMap: updaterMap$5,
      eventMap: eventMap$5,
      prevProps: prevProps,
      nextProps: props,
      instance: instance
    });
    return function cleanup() {
      unregisterEvents(registeredEvents);
    };
  }, [props, instance, prevProps]);

  if (containerElementRef.current === null) {
    return createElement(Fragment, null);
  } else {
    return createElement(Fragment, null, createPortal(Children.only(children), containerElementRef.current));
  }
}

var InfoBox = /*#__PURE__*/
memo(InfoBoxComponent);

var eventMap$6 = {
  onCloseClick: 'closeclick',
  onContentChanged: 'content_changed',
  onDomReady: 'domready',
  onPositionChanged: 'position_changed',
  onZindexChanged: 'zindex_changed'
};
var updaterMap$6 = {
  options: function options(instance, _options) {
    instance.setOptions(_options);
  },
  position: function position(instance, _position) {
    instance.setPosition(_position);
  },
  zIndex: function zIndex(instance, _zIndex) {
    instance.setZIndex(_zIndex);
  }
};

function InfoWindow(props) {
  var children = props.children,
      anchor = props.anchor,
      options = props.options,
      onLoad = props.onLoad,
      onUnmount = props.onUnmount;
  var map = useContext(MapContext);
  var prevProps = usePrevious(props);

  var _React$useState = useState(null),
      containerElement = _React$useState[0],
      setContainerElement = _React$useState[1];

  var _React$useState2 = useState(null),
      instance = _React$useState2[0],
      setInstance = _React$useState2[1];

  useEffect(function effect() {
    if (map !== null) {
      if (instance === null) {
        setInstance(new google.maps.InfoWindow(_extends({}, options || {})));
        setContainerElement(document.createElement('div'));
      }

      if (instance !== null && containerElement !== null) {
        instance.setContent(containerElement);

        if (anchor) {
          instance.open(map, anchor);
        } else if (instance.getPosition()) {
          instance.open(map);
        } else {
           process.env.NODE_ENV !== "production" ? invariant(false, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.") : invariant(false) ;
        }

        if (onLoad) {
          onLoad(instance);
        }
      }
    }

    return function cleanup() {
      if (instance !== null) {
        if (onUnmount) {
          onUnmount(instance);
        }

        instance.close();
      }
    };
  }, [instance, anchor, containerElement, map, options, onLoad, onUnmount]);
  useEffect(function effect() {
    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({
      updaterMap: updaterMap$6,
      eventMap: eventMap$6,
      prevProps: prevProps,
      nextProps: props,
      instance: instance
    });
    return function cleanup() {
      unregisterEvents(registeredEvents);
    };
  }, [props, instance, prevProps]);
  return containerElement ? createElement(Fragment, null, createPortal(Children.only(children), containerElement)) : createElement(Fragment, null);
}

var InfoWindow$1 = /*#__PURE__*/
memo(InfoWindow);

var eventMap$7 = {
  onClick: 'click',
  onDblClick: 'dblclick',
  onDrag: 'drag',
  onDragEnd: 'dragend',
  onDragStart: 'dragstart',
  onMouseDown: 'mousedown',
  onMouseMove: 'mousemove',
  onMouseOut: 'mouseout',
  onMouseOver: 'mouseover',
  onMouseUp: 'mouseup',
  onRightClick: 'rightclick'
};
var updaterMap$7 = {
  draggable: function draggable(instance, _draggable) {
    instance.setDraggable(_draggable);
  },
  editable: function editable(instance, _editable) {
    instance.setEditable(_editable);
  },
  map: function map(instance, _map) {
    instance.setMap(_map);
  },
  options: function options(instance, _options) {
    instance.setOptions(_options);
  },
  path: function path(instance, _path) {
    instance.setPath(_path);
  },
  visible: function visible(instance, _visible) {
    instance.setVisible(_visible);
  }
};

function Polyline(props) {
  var options = props.options,
      onLoad = props.onLoad,
      onUnmount = props.onUnmount;
  var map = useContext(MapContext);
  var prevProps = usePrevious(props);

  var _React$useState = useState(null),
      instance = _React$useState[0],
      setInstance = _React$useState[1];

  useEffect(function effect() {
    if (map !== null) {
      if (instance === null) {
        setInstance(new google.maps.Polyline(_extends({}, options || {}, {
          map: map
        })));
      }

      if (instance !== null) {
        instance.setMap(map);

        if (onLoad) {
          onLoad(instance);
        }
      }
    }

    return function cleanup() {
      if (instance !== null) {
        if (onUnmount) {
          onUnmount(instance);
        }

        instance.setMap(null);
      }
    };
  }, [instance, map, options, onLoad, onUnmount]);
  useEffect(function effect() {
    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({
      updaterMap: updaterMap$7,
      eventMap: eventMap$7,
      prevProps: prevProps,
      nextProps: props,
      instance: instance
    });
    return function cleanup() {
      unregisterEvents(registeredEvents);
    };
  }, [props, instance, prevProps]);
  return createElement(Fragment, null);
}

var Polyline$1 = /*#__PURE__*/
memo(Polyline);

var eventMap$8 = {
  onClick: 'click',
  onDblClick: 'dblclick',
  onDrag: 'drag',
  onDragEnd: 'dragend',
  onDragStart: 'dragstart',
  onMouseDown: 'mousedown',
  onMouseMove: 'mousemove',
  onMouseOut: 'mouseout',
  onMouseOver: 'mouseover',
  onMouseUp: 'mouseup',
  onRightClick: 'rightclick'
};
var updaterMap$8 = {
  draggable: function draggable(instance, _draggable) {
    instance.setDraggable(_draggable);
  },
  editable: function editable(instance, _editable) {
    instance.setEditable(_editable);
  },
  map: function map(instance, _map) {
    instance.setMap(_map);
  },
  options: function options(instance, _options) {
    instance.setOptions(_options);
  },
  path: function path(instance, _path) {
    instance.setPath(_path);
  },
  paths: function paths(instance, _paths) {
    instance.setPaths(_paths);
  },
  visible: function visible(instance, _visible) {
    instance.setVisible(_visible);
  }
};

function Polygon(props) {
  var options = props.options,
      onLoad = props.onLoad,
      onUnmount = props.onUnmount;
  var map = useContext(MapContext);
  var prevProps = usePrevious(props);

  var _React$useState = useState(null),
      instance = _React$useState[0],
      setInstance = _React$useState[1];

  useEffect(function effect() {
    if (map !== null) {
      if (instance === null) {
        setInstance(new google.maps.Polygon(_extends({}, options || {}, {
          map: map
        })));
      }

      if (instance !== null) {
        instance.setMap(map);

        if (onLoad) {
          onLoad(instance);
        }
      }
    }

    return function cleanup() {
      if (instance !== null) {
        if (onUnmount) {
          onUnmount(instance);
        }

        instance.setMap(null);
      }
    };
  }, [instance, map, options, onLoad, onUnmount]);
  useEffect(function effect() {
    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({
      updaterMap: updaterMap$8,
      eventMap: eventMap$8,
      prevProps: prevProps,
      nextProps: props,
      instance: instance
    });
    return function cleanup() {
      unregisterEvents(registeredEvents);
    };
  }, [props, instance, prevProps]);
  return createElement(Fragment, null);
}

var Polygon$1 = /*#__PURE__*/
memo(Polygon);

var eventMap$9 = {
  onBoundsChanged: 'bounds_changed',
  onClick: 'click',
  onDblClick: 'dblclick',
  onDrag: 'drag',
  onDragEnd: 'dragend',
  onDragStart: 'dragstart',
  onMouseDown: 'mousedown',
  onMouseMove: 'mousemove',
  onMouseOut: 'mouseout',
  onMouseOver: 'mouseover',
  onMouseUp: 'mouseup',
  onRightClick: 'rightclick'
};
var updaterMap$9 = {
  bounds: function bounds(instance, _bounds) {
    instance.setBounds(_bounds);
  },
  draggable: function draggable(instance, _draggable) {
    instance.setDraggable(_draggable);
  },
  editable: function editable(instance, _editable) {
    instance.setEditable(_editable);
  },
  map: function map(instance, _map) {
    instance.setMap(_map);
  },
  options: function options(instance, _options) {
    instance.setOptions(_options);
  },
  visible: function visible(instance, _visible) {
    instance.setVisible(_visible);
  }
};

function Rectangle(props) {
  var options = props.options,
      onLoad = props.onLoad,
      onUnmount = props.onUnmount;
  var map = useContext(MapContext);
  var prevProps = usePrevious(props);

  var _React$useState = useState(null),
      instance = _React$useState[0],
      setInstance = _React$useState[1];

  useEffect(function effect() {
    if (map !== null) {
      if (instance === null) {
        setInstance(new google.maps.Rectangle(_extends({}, options || {}, {
          map: map
        })));
      }

      if (instance !== null) {
        instance.setMap(map);

        if (onLoad) {
          onLoad(instance);
        }
      }
    }

    return function cleanup() {
      if (instance !== null) {
        if (onUnmount) {
          onUnmount(instance);
        }

        instance.setMap(null);
      }
    };
  }, [instance, map, options, onLoad, onUnmount]);
  useEffect(function effect() {
    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({
      updaterMap: updaterMap$9,
      eventMap: eventMap$9,
      prevProps: prevProps,
      nextProps: props,
      instance: instance
    });
    return function cleanup() {
      unregisterEvents(registeredEvents);
    };
  }, [props, instance, prevProps]);
  return createElement(Fragment, null);
}

var Rectangle$1 = /*#__PURE__*/
memo(Rectangle);

var eventMap$a = {
  onCenterChanged: 'center_changed',
  onClick: 'click',
  onDblClick: 'dblclick',
  onDrag: 'drag',
  onDragEnd: 'dragend',
  onDragStart: 'dragstart',
  onMouseDown: 'mousedown',
  onMouseMove: 'mousemove',
  onMouseOut: 'mouseout',
  onMouseOver: 'mouseover',
  onMouseUp: 'mouseup',
  onRadiusChanged: 'radius_changed',
  onRightClick: 'rightclick'
};
var updaterMap$a = {
  center: function center(instance, _center) {
    instance.setCenter(_center);
  },
  draggable: function draggable(instance, _draggable) {
    instance.setDraggable(_draggable);
  },
  editable: function editable(instance, _editable) {
    instance.setEditable(_editable);
  },
  map: function map(instance, _map) {
    instance.setMap(_map);
  },
  options: function options(instance, _options) {
    instance.setOptions(_options);
  },
  radius: function radius(instance, _radius) {
    instance.setRadius(_radius);
  },
  visible: function visible(instance, _visible) {
    instance.setVisible(_visible);
  }
};

function Circle(props) {
  var options = props.options,
      onLoad = props.onLoad,
      onUnmount = props.onUnmount;
  var map = useContext(MapContext);
  var prevProps = usePrevious(props);

  var _React$useState = useState(null),
      instance = _React$useState[0],
      setInstance = _React$useState[1];

  useEffect(function effect() {
    if (map !== null) {
      if (instance === null) {
        setInstance(new google.maps.Circle(_extends({}, options || {}, {
          map: map
        })));
      }

      if (instance !== null) {
        instance.setMap(map);

        if (onLoad) {
          onLoad(instance);
        }
      }
    }

    return function cleanup() {
      if (instance !== null) {
        if (onUnmount) {
          onUnmount(instance);
        }

        instance.setMap(null);
      }
    };
  }, [instance, map, options, onLoad, onUnmount]);
  useEffect(function effect() {
    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({
      updaterMap: updaterMap$a,
      eventMap: eventMap$a,
      prevProps: prevProps,
      nextProps: props,
      instance: instance
    });
    return function cleanup() {
      unregisterEvents(registeredEvents);
    };
  }, [props, instance, prevProps]);
  return createElement(Fragment, null);
}

var Circle$1 = /*#__PURE__*/
memo(Circle);

var eventMap$b = {
  onAddFeature: 'addfeature',
  onClick: 'click',
  onDblClick: 'dblclick',
  onMouseDown: 'mousedown',
  onMouseOut: 'mouseout',
  onMouseOver: 'mouseover',
  onMouseUp: 'mouseup',
  onRemoveFeature: 'removefeature',
  onRemoveProperty: 'removeproperty',
  onRightClick: 'rightclick',
  onSetGeometry: 'setgeometry',
  onSetProperty: 'setproperty'
};
var updaterMap$b = {
  add: function add(instance, features) {
    instance.add(features);
  },
  addgeojson: function addgeojson(instance, geojson, options) {
    instance.addGeoJson(geojson, options);
  },
  contains: function contains(instance, feature) {
    instance.contains(feature);
  },
  foreach: function foreach(instance, callback) {
    instance.forEach(callback);
  },
  loadgeojson: function loadgeojson(instance, url, options, callback) {
    instance.loadGeoJson(url, options, callback);
  },
  overridestyle: function overridestyle(instance, feature, style) {
    instance.overrideStyle(feature, style);
  },
  remove: function remove(instance, feature) {
    instance.remove(feature);
  },
  revertstyle: function revertstyle(instance, feature) {
    instance.revertStyle(feature);
  },
  controlposition: function controlposition(instance, controlPosition) {
    instance.setControlPosition(controlPosition);
  },
  controls: function controls(instance, _controls) {
    instance.setControls(_controls);
  },
  drawingmode: function drawingmode(instance, mode) {
    instance.setDrawingMode(mode);
  },
  map: function map(instance, _map) {
    instance.setMap(_map);
  },
  style: function style(instance, _style) {
    instance.setStyle(_style);
  },
  togeojson: function togeojson(instance, // wait till @types/googlemapsapi support typescript 3.9.5
  // eslint-disable-next-line @typescript-eslint/ban-types
  callback) {
    instance.toGeoJson(callback);
  }
};

function Data(props) {
  var options = props.options,
      onLoad = props.onLoad,
      onUnmount = props.onUnmount;
  var map = useContext(MapContext);
  var prevProps = usePrevious(props);

  var _React$useState = useState(null),
      instance = _React$useState[0],
      setInstance = _React$useState[1];

  useEffect(function effect() {
    if (map !== null) {
      if (instance === null) {
        setInstance(new google.maps.Data(_extends({}, options || {}, {
          map: map
        })));
      }

      if (instance !== null) {
        instance.setMap(map);

        if (onLoad) {
          onLoad(instance);
        }
      }
    }

    return function cleanup() {
      if (instance !== null) {
        if (onUnmount) {
          onUnmount(instance);
        }

        instance.setMap(null);
      }
    };
  }, [instance, map, options, onLoad, onUnmount]);
  useEffect(function effect() {
    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({
      updaterMap: updaterMap$b,
      eventMap: eventMap$b,
      prevProps: prevProps,
      nextProps: props,
      instance: instance
    });
    return function cleanup() {
      unregisterEvents(registeredEvents);
    };
  }, [props, instance, prevProps]);
  return createElement(Fragment, null);
}

var Data$1 = /*#__PURE__*/
memo(Data);

var eventMap$c = {
  onClick: 'click',
  onDefaultViewportChanged: 'defaultviewport_changed',
  onStatusChanged: 'status_changed'
};
var updaterMap$c = {
  options: function options(instance, _options) {
    instance.setOptions(_options);
  },
  url: function url(instance, _url) {
    instance.setUrl(_url);
  },
  zIndex: function zIndex(instance, _zIndex) {
    instance.setZIndex(_zIndex);
  }
};

function KmlLayer(props) {
  var options = props.options,
      onLoad = props.onLoad,
      onUnmount = props.onUnmount;
  var map = useContext(MapContext);
  var prevProps = usePrevious(props);

  var _React$useState = useState(null),
      instance = _React$useState[0],
      setInstance = _React$useState[1];

  useEffect(function effect() {
    if (map !== null) {
      if (instance === null) {
        setInstance(new google.maps.KmlLayer(_extends({}, options || {}, {
          map: map
        })));
      }

      if (instance !== null) {
        instance.setMap(map);

        if (onLoad) {
          onLoad(instance);
        }
      }
    }

    return function cleanup() {
      if (instance !== null) {
        if (onUnmount) {
          onUnmount(instance);
        }

        instance.setMap(null);
      }
    };
  }, [instance, map, options, onLoad, onUnmount]);
  useEffect(function effect() {
    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({
      updaterMap: updaterMap$c,
      eventMap: eventMap$c,
      prevProps: prevProps,
      nextProps: props,
      instance: instance
    });
    return function cleanup() {
      unregisterEvents(registeredEvents);
    };
  }, [props, instance, prevProps]);
  return createElement(Fragment, null);
}

var KmlLayer$1 = /*#__PURE__*/
memo(KmlLayer);

function ContentMountHandler(_ref) {
  var children = _ref.children,
      onLoad = _ref.onLoad;
  useEffect(function effect() {
    if (onLoad) {
      onLoad();
    }
  }, [onLoad]);
  return createElement(Fragment, null, children);
}

var ContentMountHandler$1 = /*#__PURE__*/
memo(ContentMountHandler);

function getOffsetOverride(containerElement, getPixelPositionOffset) {
  return typeof getPixelPositionOffset === 'function' ? getPixelPositionOffset(containerElement.offsetWidth, containerElement.offsetHeight) : {};
} // eslint-disable-next-line @typescript-eslint/no-explicit-any

function createLatLng(inst, Type) {
  return new Type(inst.lat, inst.lng);
} // eslint-disable-next-line @typescript-eslint/no-explicit-any


function createLatLngBounds(inst, Type) {
  return new Type(new google.maps.LatLng(inst.ne.lat, inst.ne.lng), new google.maps.LatLng(inst.sw.lat, inst.sw.lng));
}

function ensureOfType(inst, // eslint-disable-next-line @typescript-eslint/no-explicit-any
type, // eslint-disable-next-line @typescript-eslint/no-explicit-any
factory // eslint-disable-next-line @typescript-eslint/no-explicit-any
) {
  return inst instanceof type ? inst : factory(inst, type);
}

var getLayoutStylesByBounds = function getLayoutStylesByBounds(mapCanvasProjection, offset, bounds) {
  var ne = mapCanvasProjection.fromLatLngToDivPixel(bounds.getNorthEast());
  var sw = mapCanvasProjection.fromLatLngToDivPixel(bounds.getSouthWest());

  if (ne && sw) {
    return {
      left: sw.x + offset.x + "px",
      top: ne.y + offset.y + "px",
      width: ne.x - sw.x - offset.x + "px",
      height: sw.y - ne.y - offset.y + "px"
    };
  }

  return {
    left: '-9999px',
    top: '-9999px'
  };
};

function getLayoutStylesByPosition(mapCanvasProjection, offset, position) {
  var point = mapCanvasProjection.fromLatLngToDivPixel(position);

  if (point) {
    var x = point.x,
        y = point.y;
    return {
      left: x + offset.x + "px",
      top: y + offset.y + "px"
    };
  }

  return {
    left: '-9999px',
    top: '-9999px'
  };
}

function getLayoutStyles(mapCanvasProjection, offset, bounds, position) {
  if (bounds !== undefined) {
    return getLayoutStylesByBounds(mapCanvasProjection, offset, ensureOfType(bounds, google.maps.LatLngBounds, createLatLngBounds));
  }

  if (position !== undefined) {
    return getLayoutStylesByPosition(mapCanvasProjection, offset, ensureOfType(position, google.maps.LatLng, createLatLng));
  }

  return null;
}

function convertToLatLngString(latLngLike) {
  if (!latLngLike) {
    return '';
  }

  var latLng = latLngLike instanceof google.maps.LatLng ? latLngLike : new google.maps.LatLng(latLngLike.lat, latLngLike.lng);
  return latLng + '';
}

function convertToLatLngBoundsString(latLngBoundsLike) {
  if (!latLngBoundsLike) {
    return '';
  }

  var latLngBounds = latLngBoundsLike instanceof google.maps.LatLngBounds ? latLngBoundsLike : new google.maps.LatLngBounds(new google.maps.LatLng(latLngBoundsLike.south, latLngBoundsLike.east), new google.maps.LatLng(latLngBoundsLike.north, latLngBoundsLike.west));
  return latLngBounds + '';
} // const FLOAT_PANE = `floatPane`
// const MAP_PANE = `mapPane`
// const MARKER_LAYER = `markerLayer`
// const OVERLAY_LAYER = `overlayLayer`
// const OVERLAY_MOUSE_TARGET = `overlayMouseTarget`


function OverlayView(props) {
  var children = props.children,
      mapPaneName = props.mapPaneName,
      bounds = props.bounds,
      getPixelPositionOffset = props.getPixelPositionOffset,
      onLoad = props.onLoad,
      onUnmount = props.onUnmount,
      position = props.position;
  var prevProps = usePrevious(props);
  var map = useContext(MapContext);

  var _React$useState = useState(null),
      instance = _React$useState[0],
      setInstance = _React$useState[1];

  var _React$useState2 = useState(null),
      containerStyle = _React$useState2[0],
      setContainerStyle = _React$useState2[1];

  var mapPanelRef = useRef(null);
  var containerRef = useRef(null);
  var onPositionElement = useCallback(function callback() {
    if (instance !== null) {
      var mapCanvasProjection = instance.getProjection();

      var offset = _extends({
        x: 0,
        y: 0
      }, containerRef.current ? getOffsetOverride(containerRef.current, getPixelPositionOffset) : {});

      var layoutStyles = getLayoutStyles(mapCanvasProjection, offset, bounds, position);
      setContainerStyle(layoutStyles);
    }
  }, [bounds, getPixelPositionOffset, instance, position]);
  var draw = useCallback(function callback() {
    onPositionElement();
  }, [onPositionElement]);
  var onRemove = useCallback(function callback() {
    mapPanelRef.current = null;
  }, []);
  var handleOverlayViewCallback = useCallback(function callback() {
    if (instance !== null && onLoad) {
      onLoad(instance);
    }

    onPositionElement();
  }, [instance, onLoad, onPositionElement]);
  var onAdd = useCallback(function callback() {
    !!!mapPaneName ? process.env.NODE_ENV !== "production" ? invariant(false, "OverlayView requires mapPaneName but got %s", mapPaneName) : invariant(false) : void 0; // https://developers.google.com/maps/documentation/javascript/3.exp/reference#MapPanes

    if (instance !== null) {
      var mapPanes = instance.getPanes();

      if (!mapPanes) {
        return;
      }

      mapPanelRef.current = mapPanes[mapPaneName];
    }
  }, [instance, mapPaneName]);
  useEffect(function effect() {
    var instance = new google.maps.OverlayView(); // You must implement three methods: onAdd(), draw(), and onRemove().

    instance.onAdd = onAdd;
    instance.draw = draw;
    instance.onRemove = onRemove; // the onAdd() method and setMap(null) in order to trigger the onRemove() method.
    // You must call setMap() with a valid Map object to trigger the call to

    instance.setMap(map);
    setInstance(instance);
    return function cleanup() {
      if (instance !== null) {
        if (onUnmount) {
          onUnmount(instance);
        }

        instance.setMap(null);
      }
    };
  }, [draw, map, onAdd, onRemove, onUnmount]);
  useEffect(function effect() {
    var prevPositionString = convertToLatLngString(prevProps.position);
    var positionString = convertToLatLngString(position);
    var prevBoundsString = convertToLatLngBoundsString(prevProps.bounds);
    var boundsString = convertToLatLngBoundsString(bounds);
    var timeout = 0;

    if (prevPositionString !== positionString || prevBoundsString !== boundsString) {
      timeout = window.setTimeout(function () {
        instance !== null && instance.draw();
      }, 0);
    }

    return function cleanup() {
      window.clearTimeout(timeout);
    };
  }, [bounds, instance, position, prevProps.bounds, prevProps.position]);
  var containerStyleMemo = useMemo(function memo() {
    return _extends({}, containerStyle, {
      position: 'absolute'
    });
  }, [containerStyle]);
  return mapPanelRef.current !== null ? createPortal(createElement("div", {
    ref: containerRef,
    style: containerStyleMemo
  }, createElement(ContentMountHandler$1, {
    onLoad: handleOverlayViewCallback
  }, Children.only(children))), mapPanelRef.current) : createElement(Fragment, null);
}

var OverlayView$1 = /*#__PURE__*/
memo(OverlayView);

function noop() {
  return;
}

var eventMap$d = {
  onDblClick: 'dblclick',
  onClick: 'click'
};
var updaterMap$d = {
  opacity: function opacity(instance, _opacity) {
    instance.setOpacity(_opacity);
  }
};

function GroundOverlay(props) {
  var options = props.options,
      url = props.url,
      bounds = props.bounds,
      _props$onLoad = props.onLoad,
      onLoad = _props$onLoad === void 0 ? noop : _props$onLoad,
      onUnmount = props.onUnmount;
  var map = useContext(MapContext);
  var prevProps = usePrevious(props);

  var _React$useState = useState(null),
      instance = _React$useState[0],
      setInstance = _React$useState[1];

  useEffect(function effect() {
    !(!!url || !!bounds) ? process.env.NODE_ENV !== "production" ? invariant(false, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655") : invariant(false) : void 0;

    if (map !== null) {
      if (instance === null) {
        setInstance(new google.maps.GroundOverlay(url, bounds, _extends({}, options || {}, {
          map: map
        })));
      }

      if (instance !== null) {
        instance.setMap(map);

        if (onLoad) {
          onLoad(instance);
        }
      }
    }

    return function cleanup() {
      if (instance !== null) {
        if (onUnmount) {
          onUnmount(instance);
        }

        instance.setMap(null);
      }
    };
  }, [instance, map, bounds, url, options, onLoad, onUnmount]);
  useEffect(function effect() {
    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({
      updaterMap: updaterMap$d,
      eventMap: eventMap$d,
      prevProps: prevProps,
      nextProps: props,
      instance: instance
    });
    return function cleanup() {
      unregisterEvents(registeredEvents);
    };
  }, [props, instance, prevProps]);
  return createElement(Fragment, null);
}

var GroundOverlay$1 = /*#__PURE__*/
memo(GroundOverlay);

var eventMap$e = {};
var updaterMap$e = {
  data: function data(instance, _data) {
    instance.setData(_data);
  },
  map: function map(instance, _map) {
    instance.setMap(_map);
  },
  options: function options(instance, _options) {
    instance.setOptions(_options);
  }
};

function HeatmapLayer(props) {
  var data = props.data,
      options = props.options,
      onLoad = props.onLoad,
      onUnmount = props.onUnmount;
  var map = useContext(MapContext);
  var prevProps = usePrevious(props);

  var _React$useState = useState(null),
      instance = _React$useState[0],
      setInstance = _React$useState[1];

  useEffect(function effect() {
    !!!google.maps.visualization ? process.env.NODE_ENV !== "production" ? invariant(false, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization) : invariant(false) : void 0;
    !!!data ? process.env.NODE_ENV !== "production" ? invariant(false, 'data property is required in HeatmapLayer %s', data) : invariant(false) : void 0;

    if (map !== null) {
      if (instance === null) {
        setInstance(new google.maps.visualization.HeatmapLayer(_extends({}, options || {}, {
          data: data,
          map: map
        })));
      }

      if (instance !== null) {
        instance.setMap(map);

        if (onLoad) {
          onLoad(instance);
        }
      }
    }

    return function cleanup() {
      if (instance !== null) {
        if (onUnmount) {
          onUnmount(instance);
        }

        instance.setMap(null);
      }
    };
  }, [instance, data, map, options, onLoad, onUnmount]);
  useEffect(function effect() {
    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({
      updaterMap: updaterMap$e,
      eventMap: eventMap$e,
      prevProps: prevProps,
      nextProps: props,
      instance: instance
    });
    return function cleanup() {
      unregisterEvents(registeredEvents);
    };
  }, [props, instance, prevProps]);
  return createElement(Fragment, null);
}

var HeatmapLayer$1 = /*#__PURE__*/
memo(HeatmapLayer);

var eventMap$f = {
  onCloseClick: 'closeclick',
  onPanoChanged: 'pano_changed',
  onPositionChanged: 'position_changed',
  onPovChanged: 'pov_changed',
  onResize: 'resize',
  onStatusChanged: 'status_changed',
  onVisibleChanged: 'visible_changed',
  onZoomChanged: 'zoom_changed'
};
var updaterMap$f = {
  register: function register(instance, provider, options) {
    instance.registerPanoProvider(provider, options);
  },
  links: function links(instance, _links) {
    instance.setLinks(_links);
  },
  motionTracking: function motionTracking(instance, _motionTracking) {
    instance.setMotionTracking(_motionTracking);
  },
  options: function options(instance, _options) {
    instance.setOptions(_options);
  },
  pano: function pano(instance, _pano) {
    instance.setPano(_pano);
  },
  position: function position(instance, _position) {
    instance.setPosition(_position);
  },
  pov: function pov(instance, _pov) {
    instance.setPov(_pov);
  },
  visible: function visible(instance, _visible) {
    instance.setVisible(_visible);
  },
  zoom: function zoom(instance, _zoom) {
    instance.setZoom(_zoom);
  }
};

function StreetViewPanorama(props) {
  var options = props.options,
      onLoad = props.onLoad,
      onUnmount = props.onUnmount;
  var map = useContext(MapContext);
  var prevProps = usePrevious(props);

  var _React$useState = useState(null),
      instance = _React$useState[0],
      setInstance = _React$useState[1];

  useEffect(function effect() {
    if (map !== null) {
      if (instance === null) {
        setInstance(map.getStreetView());
      }

      if (instance !== null) {
        if (onLoad) {
          onLoad(instance);
        }
      }
    }

    return function cleanup() {
      if (instance !== null) {
        if (onUnmount) {
          onUnmount(instance);
        }

        instance.setVisible(false);
      }
    };
  }, [instance, map, options, onLoad, onUnmount]);
  useEffect(function effect() {
    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({
      updaterMap: updaterMap$f,
      eventMap: eventMap$f,
      prevProps: prevProps,
      nextProps: props,
      instance: instance
    });
    return function cleanup() {
      unregisterEvents(registeredEvents);
    };
  }, [props, instance, prevProps]);
  return createElement(Fragment, null);
}

function StreetViewService(props) {
  var onLoad = props.onLoad,
      onUnmount = props.onUnmount;

  var _React$useState = useState(null),
      instance = _React$useState[0],
      setInstance = _React$useState[1];

  useEffect(function effect() {
    var streetViewService = new google.maps.StreetViewService();
    setInstance(streetViewService);

    if (instance !== null && onLoad) {
      onLoad(instance);
    }

    return function callback() {
      if (instance !== null) {
        if (onUnmount) {
          onUnmount(instance);
        }
      }
    };
  }, [instance, onLoad, onUnmount]);
  return createElement(Fragment, null);
}

var StreetViewService$1 = /*#__PURE__*/
memo(StreetViewService);

function DirectionsService(props) {
  var options = props.options,
      callback = props.callback,
      onLoad = props.onLoad,
      onUnmount = props.onUnmount;

  var _React$useState = useState(null),
      instance = _React$useState[0],
      setInstance = _React$useState[1];

  useEffect(function effect() {
    !!!options ? process.env.NODE_ENV !== "production" ? invariant(false, 'DirectionsService expected options object as parameter, but got %s', options) : invariant(false) : void 0;

    if (instance === null) {
      setInstance(new google.maps.DirectionsService());
    }

    if (instance !== null) {
      if (onLoad) {
        onLoad(instance);
      }
    }

    return function cleanup() {
      if (instance !== null) {
        if (onUnmount) {
          onUnmount(instance);
        }
      }
    };
  }, [instance, options, onLoad, onUnmount]);
  useEffect(function effect() {
    if (instance !== null) {
      instance.route(options, callback);
    }
  }, [instance, options, callback]);
  return createElement(Fragment, null);
}

var DirectionsService$1 = /*#__PURE__*/
memo(DirectionsService);

var eventMap$g = {
  onDirectionsChanged: 'directions_changed'
};
var updaterMap$g = {
  directions: function directions(instance, _directions) {
    instance.setDirections(_directions);
  },
  map: function map(instance, _map) {
    instance.setMap(_map);
  },
  options: function options(instance, _options) {
    instance.setOptions(_options);
  },
  panel: function panel(instance, _panel) {
    instance.setPanel(_panel);
  },
  routeIndex: function routeIndex(instance, _routeIndex) {
    instance.setRouteIndex(_routeIndex);
  }
};

function DirectionsRenderer(props) {
  var options = props.options,
      onLoad = props.onLoad,
      onUnmount = props.onUnmount;
  var map = useContext(MapContext);
  var prevProps = usePrevious(props);

  var _React$useState = useState(null),
      instance = _React$useState[0],
      setInstance = _React$useState[1];

  useEffect(function effect() {
    if (map !== null) {
      if (instance === null) {
        setInstance(new google.maps.DirectionsRenderer(options));
      }

      if (instance !== null) {
        instance.setMap(map);

        if (onLoad) {
          onLoad(instance);
        }
      }
    }

    return function cleanup() {
      if (instance !== null) {
        if (onUnmount) {
          onUnmount(instance);
        }

        instance.setMap(null);
      }
    };
  }, [instance, map, options, onLoad, onUnmount]);
  useEffect(function effect() {
    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({
      updaterMap: updaterMap$g,
      eventMap: eventMap$g,
      prevProps: prevProps,
      nextProps: props,
      instance: instance
    });
    return function cleanup() {
      unregisterEvents(registeredEvents);
    };
  }, [props, instance, prevProps]);
  return createElement(Fragment, null);
}

var DirectionsRenderer$1 = /*#__PURE__*/
memo(DirectionsRenderer);

function DistanceMatrixService(props) {
  var options = props.options,
      callback = props.callback,
      onLoad = props.onLoad,
      onUnmount = props.onUnmount;

  var _React$useState = useState(null),
      instance = _React$useState[0],
      setInstance = _React$useState[1];

  useEffect(function effect() {
    !!!options ? process.env.NODE_ENV !== "production" ? invariant(false, 'DistanceMatrixService expected options object as parameter, but go %s', options) : invariant(false) : void 0;

    if (instance === null) {
      setInstance(new google.maps.DistanceMatrixService());
    }

    if (instance !== null) {
      if (onLoad) {
        onLoad(instance);
      }
    }

    return function cleanup() {
      if (instance !== null) {
        if (onUnmount) {
          onUnmount(instance);
        }
      }
    };
  }, [instance, options, onLoad, onUnmount]);
  useEffect(function effect() {
    if (instance !== null) {
      instance.getDistanceMatrix(options, callback);
    }
  }, [instance, options, callback]);
  return createElement(Fragment, null);
}

var DistanceMatrixService$1 = /*#__PURE__*/
memo(DistanceMatrixService);

var eventMap$h = {
  onPlacesChanged: 'places_changed'
};
var updaterMap$h = {
  bounds: function bounds(instance, _bounds) {
    instance.setBounds(_bounds);
  }
};

function StandaloneSearchBox(props) {
  var children = props.children,
      options = props.options,
      onLoad = props.onLoad,
      onUnmount = props.onUnmount;
  var map = useContext(MapContext);
  var prevProps = usePrevious(props);
  var containerElementRef = useRef(null);

  var _React$useState = useState(null),
      instance = _React$useState[0],
      setInstance = _React$useState[1];

  useEffect(function effect() {
    !!!google.maps.places ? process.env.NODE_ENV !== "production" ? invariant(false, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places) : invariant(false) : void 0;

    if (map !== null) {
      if (containerElementRef.current !== null) {
        var input = containerElementRef.current.querySelector('input');

        if (input !== null) {
          var searchBox = new google.maps.places.SearchBox(input, options);
          setInstance(searchBox);

          if (searchBox !== null && onLoad) {
            onLoad(searchBox);
          }
        }
      }
    }

    return function cleanup() {
      if (instance !== null) {
        if (onUnmount) {
          onUnmount(instance);
        }
      }
    };
  }, [instance, map, options, onLoad, onUnmount]);
  useEffect(function effect() {
    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({
      updaterMap: updaterMap$h,
      eventMap: eventMap$h,
      prevProps: prevProps,
      nextProps: props,
      instance: instance
    });
    return function cleanup() {
      unregisterEvents(registeredEvents);
    };
  }, [props, instance, prevProps]);
  return createElement("div", {
    ref: containerElementRef
  }, Children.only(children));
}

var StandaloneSearchBox$1 = /*#__PURE__*/
memo(StandaloneSearchBox);

var eventMap$i = {
  onPlaceChanged: 'place_changed'
};
var updaterMap$i = {
  bounds: function bounds(instance, _bounds) {
    instance.setBounds(_bounds);
  },
  restrictions: function restrictions(instance, _restrictions) {
    instance.setComponentRestrictions(_restrictions);
  },
  fields: function fields(instance, _fields) {
    instance.setFields(_fields);
  },
  options: function options(instance, _options) {
    instance.setOptions(_options);
  },
  types: function types(instance, _types) {
    instance.setTypes(_types);
  }
};

function Autocomplete(props) {
  var children = props.children,
      options = props.options,
      onLoad = props.onLoad,
      onUnmount = props.onUnmount;
  var map = useContext(MapContext);
  var prevProps = usePrevious(props);
  var containerElementRef = useRef(null);

  var _React$useState = useState(null),
      instance = _React$useState[0],
      setInstance = _React$useState[1];

  useEffect(function effect() {
    !!!google.maps.places ? process.env.NODE_ENV !== "production" ? invariant(false, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places) : invariant(false) : void 0;

    if (containerElementRef.current !== null) {
      var input = containerElementRef.current.querySelector('input');

      if (input) {
        var autocomplete = new google.maps.places.Autocomplete(input, options);
        setInstance(autocomplete);

        if (onLoad) {
          onLoad(autocomplete);
        }
      }
    }

    return function cleanup() {
      if (instance !== null) {
        if (onUnmount) {
          onUnmount(instance);
        }
      }
    };
  }, [instance, map, options, onLoad, onUnmount]);
  useEffect(function effect() {
    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({
      updaterMap: updaterMap$i,
      eventMap: eventMap$i,
      prevProps: prevProps,
      nextProps: props,
      instance: instance
    });
    return function cleanup() {
      unregisterEvents(registeredEvents);
    };
  }, [props, instance, prevProps]);
  return createElement("div", {
    ref: containerElementRef
  }, Children.only(children));
}

var Autocomplete$1 = /*#__PURE__*/
memo(Autocomplete);

export { Autocomplete$1 as Autocomplete, BicyclingLayer$1 as BicyclingLayer, Circle$1 as Circle, Data$1 as Data, DirectionsRenderer$1 as DirectionsRenderer, DirectionsService$1 as DirectionsService, DistanceMatrixService$1 as DistanceMatrixService, DrawingManager$1 as DrawingManager, GoogleMap$1 as GoogleMap, GroundOverlay$1 as GroundOverlay, HeatmapLayer$1 as HeatmapLayer, InfoBox, InfoWindow$1 as InfoWindow, KmlLayer$1 as KmlLayer, LoadScript$1 as LoadScript, LoadScriptNext$1 as LoadScriptNext, MapContext, Marker$1 as Marker, MarkerClusterer, OverlayView$1 as OverlayView, Polygon$1 as Polygon, Polyline$1 as Polyline, Rectangle$1 as Rectangle, StandaloneSearchBox$1 as StandaloneSearchBox, StreetViewPanorama, StreetViewService$1 as StreetViewService, TrafficLayer$1 as TrafficLayer, TransitLayer$1 as TransitLayer, useGoogleMap, useLoadScript };
//# sourceMappingURL=reactgooglemapsapi.esm.js.map
