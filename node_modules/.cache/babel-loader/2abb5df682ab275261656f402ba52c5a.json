{"ast":null,"code":"import { createContext, useContext, useRef, useEffect, memo, useState, createRef, createElement, Fragment, useCallback, Children, isValidElement, cloneElement, useMemo } from 'react';\nimport invariant from 'invariant';\nimport { Clusterer } from '@react-google-maps/marker-clusterer';\nimport { createPortal } from 'react-dom';\nimport { InfoBox as InfoBox$1 } from '@react-google-maps/infobox';\nvar MapContext = /*#__PURE__*/createContext(null);\n\nfunction useGoogleMap() {\n  !!!useContext ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'useGoogleMap is React hook and requires React version 16.8+') : invariant(false) : void 0;\n  var map = useContext(MapContext);\n  !!!map ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'useGoogleMap needs a GoogleMap available up in the tree') : invariant(false) : void 0;\n  return map;\n} // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any\n\n\nvar reduce = function reduce(obj, fn, acc) {\n  return Object.keys(obj).reduce(function reducer(newAcc, key) {\n    return fn(newAcc, obj[key], key);\n  }, acc);\n}; // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any\n\n\nfunction forEach(obj, fn) {\n  Object.keys(obj).forEach(function callbackfn(key) {\n    return fn(obj[key], key);\n  });\n}\n/* global google */\n\n\nfunction applyUpdaterToNextProps(updaterMap, prevProps, nextProps, instance) {\n  var map = {};\n\n  function iter(fn, key) {\n    var nextValue = nextProps[key];\n\n    if (nextValue !== prevProps[key]) {\n      map[key] = nextValue;\n      fn(instance, nextValue);\n    }\n  }\n\n  forEach(updaterMap, iter);\n  return map;\n}\n\nfunction registerEvents(props, instance, eventMap) {\n  var registeredList = reduce(eventMap, function reducer(acc, googleEventName, onEventName) {\n    if (typeof props[onEventName] === 'function') {\n      acc.push(google.maps.event.addListener(instance, googleEventName, props[onEventName]));\n    }\n\n    return acc;\n  }, []);\n  return registeredList;\n}\n\nfunction unregisterEvent(registered) {\n  google.maps.event.removeListener(registered);\n}\n\nfunction unregisterEvents(events) {\n  if (events === void 0) {\n    events = [];\n  }\n\n  events.forEach(unregisterEvent);\n}\n\nfunction applyUpdatersToPropsAndRegisterEvents(_ref) {\n  var updaterMap = _ref.updaterMap,\n      eventMap = _ref.eventMap,\n      prevProps = _ref.prevProps,\n      nextProps = _ref.nextProps,\n      instance = _ref.instance;\n  var registeredEvents = registerEvents(nextProps, instance, eventMap);\n  applyUpdaterToNextProps(updaterMap, prevProps, nextProps, instance);\n  return registeredEvents;\n}\n\nfunction usePrevious(props) {\n  var ref = useRef(props);\n  useEffect(function effect() {\n    ref.current = props;\n  }, [props]);\n  return ref.current;\n}\n\nvar eventMap = {\n  onDblClick: 'dblclick',\n  onDragEnd: 'dragend',\n  onDragStart: 'dragstart',\n  onMapTypeIdChanged: 'maptypeid_changed',\n  onMouseMove: 'mousemove',\n  onMouseOut: 'mouseout',\n  onMouseOver: 'mouseover',\n  onMouseDown: 'mousedown',\n  onMouseUp: 'mouseup',\n  onRightClick: 'rightclick',\n  onTilesLoaded: 'tilesloaded',\n  onBoundsChanged: 'bounds_changed',\n  onCenterChanged: 'center_changed',\n  onClick: 'click',\n  onDrag: 'drag',\n  onHeadingChanged: 'heading_changed',\n  onIdle: 'idle',\n  onProjectionChanged: 'projection_changed',\n  onResize: 'resize',\n  onTiltChanged: 'tilt_changed',\n  onZoomChanged: 'zoom_changed'\n};\nvar updaterMap = {\n  extraMapTypes: function extraMapTypes(map, extra) {\n    extra.forEach(function forEachExtra(it, i) {\n      map.mapTypes.set(String(i), it);\n    });\n  },\n  center: function center(map, _center) {\n    map.setCenter(_center);\n  },\n  clickableIcons: function clickableIcons(map, clickable) {\n    map.setClickableIcons(clickable);\n  },\n  heading: function heading(map, _heading) {\n    map.setHeading(_heading);\n  },\n  mapTypeId: function mapTypeId(map, _mapTypeId) {\n    map.setMapTypeId(_mapTypeId);\n  },\n  options: function options(map, _options) {\n    map.setOptions(_options);\n  },\n  streetView: function streetView(map, _streetView) {\n    map.setStreetView(_streetView);\n  },\n  tilt: function tilt(map, _tilt) {\n    map.setTilt(_tilt);\n  },\n  zoom: function zoom(map, _zoom) {\n    map.setZoom(_zoom);\n  }\n};\n\nfunction GoogleMap(props) {\n  var children = props.children,\n      options = props.options,\n      id = props.id,\n      mapContainerStyle = props.mapContainerStyle,\n      mapContainerClassName = props.mapContainerClassName,\n      onLoad = props.onLoad,\n      onUnmount = props.onUnmount;\n\n  var _React$useState = useState(null),\n      instance = _React$useState[0],\n      setInstance = _React$useState[1];\n\n  var mapRef = createRef();\n  var prevProps = usePrevious(props);\n  useEffect(function effect() {\n    if (instance === null && mapRef.current !== null) {\n      setInstance(new google.maps.Map(mapRef.current, options));\n    }\n\n    if (instance !== null) {\n      if (onLoad) {\n        onLoad(instance);\n      }\n    }\n\n    return function cleanup() {\n      if (instance !== null) {\n        if (onUnmount) {\n          onUnmount(instance);\n        }\n      }\n    };\n  }, [instance, options, onLoad, onUnmount, mapRef]);\n  useEffect(function effect() {\n    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap,\n      eventMap: eventMap,\n      prevProps: prevProps,\n      nextProps: props,\n      instance: instance\n    });\n    return function cleanup() {\n      unregisterEvents(registeredEvents);\n    };\n  }, [props, instance, prevProps]);\n  return createElement(\"div\", {\n    id: id,\n    ref: mapRef,\n    style: mapContainerStyle,\n    className: mapContainerClassName\n  }, createElement(MapContext.Provider, {\n    value: instance\n  }, instance !== null ? children : createElement(Fragment, null)));\n}\n\nvar GoogleMap$1 = /*#__PURE__*/memo(GoogleMap);\nvar isBrowser = typeof document !== 'undefined';\n\nfunction injectScript(_ref) {\n  var url = _ref.url,\n      id = _ref.id;\n\n  if (!isBrowser) {\n    return Promise.reject(new Error('document is undefined'));\n  }\n\n  return new Promise(function injectScriptCallback(resolve, reject) {\n    var existingScript = document.getElementById(id);\n    var windowWithGoogleMap = window;\n\n    if (existingScript) {\n      // Same script id/url: keep same script\n      var dataStateAttribute = existingScript.getAttribute('data-state');\n\n      if (existingScript.src === url && dataStateAttribute !== 'error') {\n        if (dataStateAttribute === 'ready') {\n          return resolve(id);\n        } else {\n          var originalInitMap = windowWithGoogleMap.initMap;\n          var originalErrorCallback = existingScript.onerror;\n\n          windowWithGoogleMap.initMap = function initMap() {\n            if (originalInitMap) {\n              originalInitMap();\n            }\n\n            resolve(id);\n          };\n\n          existingScript.onerror = function onerror(err) {\n            if (originalErrorCallback) {\n              originalErrorCallback(err);\n            }\n\n            reject(err);\n          };\n        }\n      } // Same script id, but either\n      // 1. requested URL is different\n      // 2. script failed to load\n      else {\n          existingScript.remove();\n        }\n    }\n\n    var script = document.createElement('script');\n    script.type = 'text/javascript';\n    script.src = url;\n    script.id = id;\n    script.async = true;\n\n    script.onerror = function onerror(err) {\n      script.setAttribute('data-state', 'error');\n      reject(err);\n    };\n\n    windowWithGoogleMap.initMap = function onload() {\n      script.setAttribute('data-state', 'ready');\n      resolve(id);\n    };\n\n    document.head.appendChild(script);\n  })[\"catch\"](function (err) {\n    console.error('injectScript error: ', err);\n    throw err;\n  });\n}\n\nvar isRobotoStyle = function isRobotoStyle(element) {\n  // roboto font download\n  if (element.href && element.href.indexOf('https://fonts.googleapis.com/css?family=Roboto') === 0) {\n    return true;\n  } // roboto style elements\n\n\n  if (element.tagName.toLowerCase() === 'style' && // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  element.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  element.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  element.styleSheet.cssText.replace('\\r\\n', '').indexOf('.gm-style') === 0) {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    element.styleSheet.cssText = '';\n    return true;\n  } // roboto style elements for other browsers\n\n\n  if (element.tagName.toLowerCase() === 'style' && element.innerHTML && element.innerHTML.replace('\\r\\n', '').indexOf('.gm-style') === 0) {\n    element.innerHTML = '';\n    return true;\n  } // when google tries to add empty style\n\n\n  if (element.tagName.toLowerCase() === 'style' && // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  !element.styleSheet && !element.innerHTML) {\n    return true;\n  }\n\n  return false;\n}; // Preventing the Google Maps library from downloading an extra font\n\n\nvar preventGoogleFonts = function preventGoogleFonts() {\n  // we override these methods only for one particular head element\n  // default methods for other elements are not affected\n  var head = document.getElementsByTagName('head')[0];\n  var trueInsertBefore = head.insertBefore.bind(head); // TODO: adding return before reflect solves the TS issue\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n\n  head.insertBefore = function insertBefore(newElement, referenceElement) {\n    if (!isRobotoStyle(newElement)) {\n      Reflect.apply(trueInsertBefore, head, [newElement, referenceElement]);\n    }\n  };\n\n  var trueAppend = head.appendChild.bind(head); // TODO: adding return before reflect solves the TS issue\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n\n  head.appendChild = function appendChild(textNode) {\n    if (!isRobotoStyle(textNode)) {\n      Reflect.apply(trueAppend, head, [textNode]);\n    }\n  };\n};\n\nfunction makeLoadScriptUrl(_ref) {\n  var googleMapsApiKey = _ref.googleMapsApiKey,\n      googleMapsClientId = _ref.googleMapsClientId,\n      _ref$version = _ref.version,\n      version = _ref$version === void 0 ? 'weekly' : _ref$version,\n      language = _ref.language,\n      region = _ref.region,\n      libraries = _ref.libraries,\n      channel = _ref.channel;\n  var params = [];\n  !(googleMapsApiKey && googleMapsClientId || !(googleMapsApiKey && googleMapsClientId)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time.') : invariant(false) : void 0;\n\n  if (googleMapsApiKey) {\n    params.push(\"key=\" + googleMapsApiKey);\n  } else if (googleMapsClientId) {\n    params.push(\"client=\" + googleMapsClientId);\n  }\n\n  if (version) {\n    params.push(\"v=\" + version);\n  }\n\n  if (language) {\n    params.push(\"language=\" + language);\n  }\n\n  if (region) {\n    params.push(\"region=\" + region);\n  }\n\n  if (libraries && libraries.length) {\n    params.push(\"libraries=\" + libraries.sort().join(','));\n  }\n\n  if (channel) {\n    params.push(\"channel=\" + channel);\n  }\n\n  params.push('callback=initMap');\n  return \"https://maps.googleapis.com/maps/api/js?\" + params.join('&');\n}\n\nvar cleaningUp = false;\n\nfunction DefaultLoadingElement() {\n  return createElement(\"div\", null, \"Loading...\");\n}\n\nvar defaultLoadScriptProps = {\n  id: 'script-loader',\n  version: 'weekly'\n};\n\nfunction LoadScript(props) {\n  var googleMapsApiKey = props.googleMapsApiKey,\n      googleMapsClientId = props.googleMapsClientId,\n      children = props.children,\n      _props$id = props.id,\n      id = _props$id === void 0 ? 'script-loader' : _props$id,\n      _props$version = props.version,\n      version = _props$version === void 0 ? 'weekly' : _props$version,\n      language = props.language,\n      region = props.region,\n      channel = props.channel,\n      libraries = props.libraries,\n      loadingElement = props.loadingElement,\n      onLoad = props.onLoad,\n      onUnmount = props.onUnmount,\n      onError = props.onError,\n      preventGoogleFontsLoading = props.preventGoogleFontsLoading;\n  var prevProps = usePrevious(props);\n\n  var _React$useState = useState(false),\n      loaded = _React$useState[0],\n      setLoaded = _React$useState[1];\n\n  var check = useRef(null);\n  var injectScript$1 = useCallback(function callback() {\n    if (preventGoogleFontsLoading) {\n      preventGoogleFonts();\n    }\n\n    !!!id ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'LoadScript requires \"id\" prop to be a string: %s', id) : invariant(false) : void 0;\n    var injectScriptOptions = {\n      id: id,\n      url: makeLoadScriptUrl({\n        googleMapsApiKey: googleMapsApiKey,\n        googleMapsClientId: googleMapsClientId,\n        version: version,\n        language: language,\n        region: region,\n        libraries: libraries,\n        channel: channel\n      })\n    };\n    injectScript(injectScriptOptions).then(function onfulfilled() {\n      if (onLoad) {\n        onLoad();\n      }\n\n      setLoaded(true);\n      return;\n    })[\"catch\"](function onrejected(err) {\n      if (onError) {\n        onError(err);\n      }\n\n      console.error(\"\\n          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (\" + (googleMapsApiKey || '-') + \") or Client ID (\" + (googleMapsClientId || '-') + \") to <LoadScript />\\n          Otherwise it is a Network issue.\\n        \");\n    });\n  }, [googleMapsApiKey, id, version, language, region, channel, libraries, googleMapsClientId, preventGoogleFontsLoading, onError, onLoad]);\n  var isCleaningUp = useCallback(function callback() {\n    try {\n      var promiseCallback = function promiseCallback(resolve) {\n        if (!cleaningUp) {\n          resolve();\n        } else {\n          if (isBrowser) {\n            var timer = window.setInterval(function interval() {\n              if (!cleaningUp) {\n                window.clearInterval(timer);\n                resolve();\n              }\n            }, 1);\n          }\n        }\n\n        return;\n      };\n\n      return Promise.resolve(new Promise(promiseCallback));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }, []);\n  var cleanup = useCallback(function callback() {\n    cleaningUp = true;\n    var script = document.getElementById(id);\n\n    if (script && script.parentNode) {\n      script.parentNode.removeChild(script);\n    }\n\n    Array.prototype.slice.call(document.getElementsByTagName('script')).filter(function filter(script) {\n      return typeof script.src === 'string' && script.src.includes('maps.googleapis');\n    }).forEach(function forEach(script) {\n      if (script.parentNode) {\n        script.parentNode.removeChild(script);\n      }\n    });\n    Array.prototype.slice.call(document.getElementsByTagName('link')).filter(function filter(link) {\n      return link.href === 'https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans';\n    }).forEach(function forEach(link) {\n      if (link.parentNode) {\n        link.parentNode.removeChild(link);\n      }\n    });\n    Array.prototype.slice.call(document.getElementsByTagName('style')).filter(function filter(style) {\n      return style.innerText !== undefined && style.innerText.length > 0 && style.innerText.includes('.gm-');\n    }).forEach(function forEach(style) {\n      if (style.parentNode) {\n        style.parentNode.removeChild(style);\n      }\n    });\n  }, [id]);\n  useEffect(function effect() {\n    if (isBrowser) {\n      if (window.google && !cleaningUp) {\n        console.error('google api is already presented');\n        return function cleanup() {\n          return;\n        };\n      }\n\n      isCleaningUp().then(injectScript$1)[\"catch\"](function onrejected(err) {\n        console.error('Error at injecting script after cleaning up: ', err);\n      });\n    }\n\n    return function callback() {\n      if (isBrowser) {\n        cleanup();\n\n        var timeoutCallback = function timeoutCallback() {\n          // eslint-disable-next-line react-hooks/exhaustive-deps\n          if (check.current === null) {\n            delete window.google;\n            cleaningUp = false;\n          }\n        };\n\n        window.setTimeout(timeoutCallback, 1);\n\n        if (onUnmount) {\n          onUnmount();\n        }\n      }\n    };\n  }, [cleanup, isCleaningUp, onUnmount, injectScript$1]);\n  useEffect(function effect() {\n    if (libraries !== prevProps.libraries) {\n      console.warn('Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables');\n    }\n\n    if (isBrowser && prevProps.language !== language) {\n      cleanup();\n      setLoaded(false);\n      delete window.google;\n      injectScript$1();\n    }\n  }, [cleanup, injectScript$1, language, libraries, prevProps.language, prevProps.libraries]);\n  return createElement(Fragment, null, createElement(\"div\", {\n    ref: check\n  }), loaded ? children : loadingElement || createElement(DefaultLoadingElement, null));\n}\n\nvar LoadScript$1 = /*#__PURE__*/memo(LoadScript);\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar previouslyLoadedUrl;\n\nfunction useLoadScript(_ref) {\n  var _ref$id = _ref.id,\n      id = _ref$id === void 0 ? defaultLoadScriptProps.id : _ref$id,\n      _ref$version = _ref.version,\n      version = _ref$version === void 0 ? defaultLoadScriptProps.version : _ref$version,\n      googleMapsApiKey = _ref.googleMapsApiKey,\n      googleMapsClientId = _ref.googleMapsClientId,\n      language = _ref.language,\n      region = _ref.region,\n      libraries = _ref.libraries,\n      preventGoogleFontsLoading = _ref.preventGoogleFontsLoading,\n      channel = _ref.channel;\n  var isMounted = useRef(false);\n\n  var _React$useState = useState(false),\n      isLoaded = _React$useState[0],\n      setLoaded = _React$useState[1];\n\n  var _React$useState2 = useState(undefined),\n      loadError = _React$useState2[0],\n      setLoadError = _React$useState2[1];\n\n  useEffect(function trackMountedState() {\n    isMounted.current = true;\n    return function () {\n      isMounted.current = false;\n    };\n  }, []);\n  useEffect(function applyPreventGoogleFonts() {\n    if (isBrowser && preventGoogleFontsLoading) {\n      preventGoogleFonts();\n    }\n  }, [preventGoogleFontsLoading]);\n  useEffect(function validateLoadedState() {\n    if (isLoaded) {\n      !!!window.google ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'useLoadScript was marked as loaded, but window.google is not present. Something went wrong.') : invariant(false) : void 0;\n    }\n  }, [isLoaded]);\n  var url = makeLoadScriptUrl({\n    version: version,\n    googleMapsApiKey: googleMapsApiKey,\n    googleMapsClientId: googleMapsClientId,\n    language: language,\n    region: region,\n    libraries: libraries,\n    channel: channel\n  });\n  useEffect(function loadScriptAndModifyLoadedState() {\n    if (!isBrowser) {\n      return;\n    }\n\n    function setLoadedIfMounted() {\n      if (isMounted.current) {\n        setLoaded(true);\n        previouslyLoadedUrl = url;\n      }\n    }\n\n    if (window.google && previouslyLoadedUrl === url) {\n      setLoadedIfMounted();\n      return;\n    }\n\n    injectScript({\n      id: id,\n      url: url\n    }).then(setLoadedIfMounted)[\"catch\"](function handleInjectError(err) {\n      if (isMounted.current) {\n        setLoadError(err);\n      }\n\n      console.warn(\"\\n        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (\" + (googleMapsApiKey || '-') + \") or Client ID (\" + (googleMapsClientId || '-') + \")\\n        Otherwise it is a Network issue.\\n      \");\n      console.error(err);\n    });\n  }, [id, url, googleMapsApiKey, googleMapsClientId]);\n  var prevLibraries = useRef();\n  useEffect(function checkPerformance() {\n    if (prevLibraries.current && libraries !== prevLibraries.current) {\n      console.warn('Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables');\n    }\n\n    prevLibraries.current = libraries;\n  }, [libraries]);\n  return {\n    isLoaded: isLoaded,\n    loadError: loadError,\n    url: url\n  };\n}\n\nvar defaultLoadingElement = /*#__PURE__*/createElement(DefaultLoadingElement, null);\n\nfunction LoadScriptNext(_ref) {\n  var loadingElement = _ref.loadingElement,\n      onLoad = _ref.onLoad,\n      onError = _ref.onError,\n      onUnmount = _ref.onUnmount,\n      children = _ref.children,\n      hookOptions = _objectWithoutPropertiesLoose(_ref, [\"loadingElement\", \"onLoad\", \"onError\", \"onUnmount\", \"children\"]);\n\n  var _useLoadScript = useLoadScript(hookOptions),\n      isLoaded = _useLoadScript.isLoaded,\n      loadError = _useLoadScript.loadError;\n\n  useEffect(function effect() {\n    if (isLoaded && typeof onLoad === 'function') {\n      onLoad();\n    }\n  }, [isLoaded, onLoad]);\n  useEffect(function effect() {\n    if (loadError && typeof onError === 'function') {\n      onError(loadError);\n    }\n  }, [loadError, onError]);\n  useEffect(function effect() {\n    return function () {\n      if (onUnmount) {\n        onUnmount();\n      }\n    };\n  }, [onUnmount]);\n  return isLoaded ? children : loadingElement || defaultLoadingElement;\n}\n\nvar LoadScriptNext$1 = /*#__PURE__*/memo(LoadScriptNext);\nvar eventMap$1 = {};\nvar updaterMap$1 = {\n  options: function options(instance, _options) {\n    instance.setOptions(_options);\n  }\n};\n\nfunction TrafficLayer(props) {\n  var options = props.options,\n      onLoad = props.onLoad,\n      onUnmount = props.onUnmount;\n  var map = useContext(MapContext);\n  var prevProps = usePrevious(props);\n\n  var _React$useState = useState(null),\n      instance = _React$useState[0],\n      setInstance = _React$useState[1];\n\n  useEffect(function effect() {\n    if (map !== null) {\n      if (instance === null) {\n        setInstance(new google.maps.TrafficLayer(_extends({}, options || {}, {\n          map: map\n        })));\n      }\n\n      if (instance !== null) {\n        instance.setMap(map);\n\n        if (onLoad) {\n          onLoad(instance);\n        }\n      }\n    }\n\n    return function cleanup() {\n      if (instance !== null) {\n        if (onUnmount) {\n          onUnmount(instance);\n        }\n\n        instance.setMap(null);\n      }\n    };\n  }, [instance, map, options, onLoad, onUnmount]);\n  useEffect(function effect() {\n    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$1,\n      eventMap: eventMap$1,\n      prevProps: prevProps,\n      nextProps: props,\n      instance: instance\n    });\n    return function cleanup() {\n      unregisterEvents(registeredEvents);\n    };\n  }, [props, instance, prevProps]);\n  return createElement(Fragment, null);\n}\n\nvar TrafficLayer$1 = /*#__PURE__*/memo(TrafficLayer);\n\nfunction BicyclingLayer(_ref) {\n  var onLoad = _ref.onLoad,\n      onUnmount = _ref.onUnmount;\n  var map = useContext(MapContext);\n\n  var _React$useState = useState(null),\n      instance = _React$useState[0],\n      setInstance = _React$useState[1];\n\n  useEffect(function effect() {\n    if (map !== null) {\n      if (instance === null) {\n        setInstance(new google.maps.BicyclingLayer());\n      }\n\n      if (instance !== null) {\n        instance.setMap(map);\n\n        if (onLoad) {\n          onLoad(instance);\n        }\n      }\n    }\n\n    return function cleanup() {\n      if (instance !== null) {\n        if (onUnmount) {\n          onUnmount(instance);\n        }\n\n        instance.setMap(null);\n      }\n    };\n  }, [instance, map, onLoad, onUnmount]);\n  return createElement(Fragment, null);\n}\n\nvar BicyclingLayer$1 = /*#__PURE__*/memo(BicyclingLayer);\n\nfunction TransitLayer(props) {\n  var onLoad = props.onLoad,\n      onUnmount = props.onUnmount;\n  var map = useContext(MapContext);\n\n  var _React$useState = useState(null),\n      instance = _React$useState[0],\n      setInstance = _React$useState[1];\n\n  useEffect(function effect() {\n    var newInstance = new google.maps.TransitLayer();\n    setInstance(newInstance);\n    newInstance.setMap(map);\n\n    if (onLoad) {\n      onLoad(newInstance);\n    }\n\n    return function cleanup() {\n      if (instance !== null) {\n        if (onUnmount) {\n          onUnmount(instance);\n        }\n\n        instance.setMap(null);\n      }\n    };\n  }, [instance, map, onLoad, onUnmount]);\n  return createElement(Fragment, null);\n}\n\nvar TransitLayer$1 = /*#__PURE__*/memo(TransitLayer);\nvar eventMap$2 = {\n  onCircleComplete: 'circlecomplete',\n  onMarkerComplete: 'markercomplete',\n  onOverlayComplete: 'overlaycomplete',\n  onPolygonComplete: 'polygoncomplete',\n  onPolylineComplete: 'polylinecomplete',\n  onRectangleComplete: 'rectanglecomplete'\n};\nvar updaterMap$2 = {\n  drawingMode: function drawingMode(instance, _drawingMode) {\n    instance.setDrawingMode(_drawingMode);\n  },\n  options: function options(instance, _options) {\n    instance.setOptions(_options);\n  }\n};\n\nfunction DrawingManager(props) {\n  var options = props.options,\n      onLoad = props.onLoad,\n      onUnmount = props.onUnmount;\n  var map = useContext(MapContext);\n  var prevProps = usePrevious(props);\n\n  var _React$useState = useState(null),\n      instance = _React$useState[0],\n      setInstance = _React$useState[1];\n\n  useEffect(function effect() {\n    !!!google.maps.drawing ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Did you include prop libraries={['drawing']} in the URL? %s\", google.maps.drawing) : invariant(false) : void 0;\n\n    if (map !== null) {\n      if (instance === null) {\n        setInstance(new google.maps.drawing.DrawingManager(_extends({}, options || {}, {\n          map: map\n        })));\n      }\n\n      if (instance !== null) {\n        instance.setMap(map);\n\n        if (onLoad) {\n          onLoad(instance);\n        }\n      }\n    }\n\n    return function cleanup() {\n      if (instance !== null) {\n        if (onUnmount) {\n          onUnmount(instance);\n        }\n\n        instance.setMap(null);\n      }\n    };\n  }, [instance, map, options, onLoad, onUnmount]);\n  useEffect(function effect() {\n    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$2,\n      eventMap: eventMap$2,\n      prevProps: prevProps,\n      nextProps: props,\n      instance: instance\n    });\n    return function cleanup() {\n      unregisterEvents(registeredEvents);\n    };\n  }, [props, instance, prevProps]);\n  return createElement(Fragment, null);\n}\n\nvar DrawingManager$1 = /*#__PURE__*/memo(DrawingManager);\nvar eventMap$3 = {\n  onAnimationChanged: 'animation_changed',\n  onClick: 'click',\n  onClickableChanged: 'clickable_changed',\n  onCursorChanged: 'cursor_changed',\n  onDblClick: 'dblclick',\n  onDrag: 'drag',\n  onDragEnd: 'dragend',\n  onDraggableChanged: 'draggable_changed',\n  onDragStart: 'dragstart',\n  onFlatChanged: 'flat_changed',\n  onIconChanged: 'icon_changed',\n  onMouseDown: 'mousedown',\n  onMouseOut: 'mouseout',\n  onMouseOver: 'mouseover',\n  onMouseUp: 'mouseup',\n  onPositionChanged: 'position_changed',\n  onRightClick: 'rightclick',\n  onShapeChanged: 'shape_changed',\n  onTitleChanged: 'title_changed',\n  onVisibleChanged: 'visible_changed',\n  onZindexChanged: 'zindex_changed'\n};\nvar updaterMap$3 = {\n  animation: function animation(instance, _animation) {\n    instance.setAnimation(_animation);\n  },\n  clickable: function clickable(instance, _clickable) {\n    instance.setClickable(_clickable);\n  },\n  cursor: function cursor(instance, _cursor) {\n    instance.setCursor(_cursor);\n  },\n  draggable: function draggable(instance, _draggable) {\n    instance.setDraggable(_draggable);\n  },\n  icon: function icon(instance, _icon) {\n    instance.setIcon(_icon);\n  },\n  label: function label(instance, _label) {\n    instance.setLabel(_label);\n  },\n  map: function map(instance, _map) {\n    instance.setMap(_map);\n  },\n  opacity: function opacity(instance, _opacity) {\n    instance.setOpacity(_opacity);\n  },\n  options: function options(instance, _options) {\n    instance.setOptions(_options);\n  },\n  position: function position(instance, _position) {\n    instance.setPosition(_position);\n  },\n  shape: function shape(instance, _shape) {\n    instance.setShape(_shape);\n  },\n  title: function title(instance, _title) {\n    instance.setTitle(_title);\n  },\n  visible: function visible(instance, _visible) {\n    instance.setVisible(_visible);\n  },\n  zIndex: function zIndex(instance, _zIndex) {\n    instance.setZIndex(_zIndex);\n  }\n};\n\nfunction Marker(props) {\n  var children = props.children,\n      options = props.options,\n      position = props.position,\n      clusterer = props.clusterer,\n      noClustererRedraw = props.noClustererRedraw,\n      onLoad = props.onLoad,\n      onUnmount = props.onUnmount;\n  var map = useContext(MapContext);\n  var prevProps = usePrevious(props);\n\n  var _React$useState = useState(null),\n      instance = _React$useState[0],\n      setInstance = _React$useState[1];\n\n  useEffect(function effect() {\n    if (map !== null) {\n      if (instance === null) {\n        var marker = new google.maps.Marker(_extends({}, options || {}, {}, clusterer ? {} : {\n          map: map\n        }, {\n          position: position\n        }));\n\n        if (clusterer) {\n          clusterer.addMarker(marker, !!noClustererRedraw);\n        } else {\n          marker.setMap(map);\n        }\n\n        setInstance(marker);\n      }\n\n      if (instance !== null) {\n        instance.setMap(map);\n\n        if (onLoad) {\n          onLoad(instance);\n        }\n      }\n    }\n\n    return function cleanup() {\n      if (instance !== null) {\n        if (onUnmount) {\n          onUnmount(instance);\n        }\n\n        if (clusterer) {\n          clusterer.removeMarker(instance, !!noClustererRedraw);\n        } else {\n          instance && instance.setMap(null);\n        }\n      }\n    };\n  }, [instance, map, options, clusterer, noClustererRedraw, position, onLoad, onUnmount]);\n  useEffect(function effect() {\n    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$3,\n      eventMap: eventMap$3,\n      prevProps: prevProps,\n      nextProps: props,\n      instance: instance\n    });\n    return function cleanup() {\n      unregisterEvents(registeredEvents);\n    };\n  }, [props, instance, prevProps]);\n\n  if (children) {\n    return createElement(Fragment, null, Children.map(children, function mapper(child) {\n      if (!isValidElement(child)) {\n        return child;\n      }\n\n      var elementChild = child;\n      return cloneElement(elementChild, {\n        anchor: instance\n      });\n    }));\n  } else {\n    return createElement(Fragment, null);\n  }\n}\n\nvar Marker$1 = /*#__PURE__*/memo(Marker);\nvar eventMap$4 = {\n  onClick: 'click',\n  onClusteringBegin: 'clusteringbegin',\n  onClusteringEnd: 'clusteringend',\n  onMouseOut: 'mouseout',\n  onMouseOver: 'mouseover'\n};\nvar updaterMap$4 = {\n  averageCenter: function averageCenter(instance, _averageCenter) {\n    instance.setAverageCenter(_averageCenter);\n  },\n  batchSizeIE: function batchSizeIE(instance, _batchSizeIE) {\n    instance.setBatchSizeIE(_batchSizeIE);\n  },\n  calculator: function calculator(instance, _calculator) {\n    instance.setCalculator(_calculator);\n  },\n  clusterClass: function clusterClass(instance, _clusterClass) {\n    instance.setClusterClass(_clusterClass);\n  },\n  enableRetinaIcons: function enableRetinaIcons(instance, _enableRetinaIcons) {\n    instance.setEnableRetinaIcons(_enableRetinaIcons);\n  },\n  gridSize: function gridSize(instance, _gridSize) {\n    instance.setGridSize(_gridSize);\n  },\n  ignoreHidden: function ignoreHidden(instance, _ignoreHidden) {\n    instance.setIgnoreHidden(_ignoreHidden);\n  },\n  imageExtension: function imageExtension(instance, _imageExtension) {\n    instance.setImageExtension(_imageExtension);\n  },\n  imagePath: function imagePath(instance, _imagePath) {\n    instance.setImagePath(_imagePath);\n  },\n  imageSizes: function imageSizes(instance, _imageSizes) {\n    instance.setImageSizes(_imageSizes);\n  },\n  maxZoom: function maxZoom(instance, _maxZoom) {\n    instance.setMaxZoom(_maxZoom);\n  },\n  minimumClusterSize: function minimumClusterSize(instance, _minimumClusterSize) {\n    instance.setMinimumClusterSize(_minimumClusterSize);\n  },\n  styles: function styles(instance, _styles) {\n    instance.setStyles(_styles);\n  },\n  title: function title(instance, _title) {\n    instance.setTitle(_title);\n  },\n  zoomOnClick: function zoomOnClick(instance, _zoomOnClick) {\n    instance.setZoomOnClick(_zoomOnClick);\n  }\n};\n\nfunction ClustererComponent(props) {\n  var children = props.children,\n      options = props.options,\n      onLoad = props.onLoad,\n      onUnmount = props.onUnmount;\n  var map = useContext(MapContext);\n  var prevProps = usePrevious(props);\n\n  var _React$useState = useState(null),\n      instance = _React$useState[0],\n      setInstance = _React$useState[1];\n\n  useEffect(function effect() {\n    if (map !== null) {\n      if (instance === null) {\n        setInstance(new Clusterer(map, [], options));\n      }\n\n      if (instance !== null) {\n        if (onLoad) {\n          onLoad(instance);\n        }\n      }\n    }\n\n    return function cleanup() {\n      if (instance !== null) {\n        if (onUnmount) {\n          onUnmount(instance);\n        } // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n\n\n        instance.setMap(null);\n      }\n    };\n  }, [instance, map, options, onLoad, onUnmount]);\n  useEffect(function effect() {\n    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$4,\n      eventMap: eventMap$4,\n      prevProps: prevProps,\n      nextProps: props,\n      instance: instance\n    });\n    return function cleanup() {\n      unregisterEvents(registeredEvents);\n    };\n  }, [props, instance, prevProps]);\n  return instance !== null ? createElement(Fragment, null, children(instance)) : createElement(Fragment, null);\n}\n\nvar MarkerClusterer = /*#__PURE__*/memo(ClustererComponent);\nvar eventMap$5 = {\n  onCloseClick: 'closeclick',\n  onContentChanged: 'content_changed',\n  onDomReady: 'domready',\n  onPositionChanged: 'position_changed',\n  onZindexChanged: 'zindex_changed'\n};\nvar updaterMap$5 = {\n  options: function options(instance, _options) {\n    instance.setOptions(_options);\n  },\n  position: function position(instance, _position) {\n    if (_position instanceof google.maps.LatLng) {\n      instance.setPosition(_position);\n    } else {\n      instance.setPosition(new google.maps.LatLng(_position.lat, _position.lng));\n    }\n  },\n  visible: function visible(instance, _visible) {\n    instance.setVisible(_visible);\n  },\n  zIndex: function zIndex(instance, _zIndex) {\n    instance.setZIndex(_zIndex);\n  }\n};\n\nfunction InfoBoxComponent(props) {\n  var children = props.children,\n      options = props.options,\n      anchor = props.anchor,\n      onLoad = props.onLoad,\n      onUnmount = props.onUnmount;\n\n  var _ref = options || {},\n      position = _ref.position,\n      infoBoxOptions = _objectWithoutPropertiesLoose(_ref, [\"position\"]);\n\n  var map = useContext(MapContext);\n  var prevProps = usePrevious(props);\n  var containerElementRef = useRef(null);\n\n  var _React$useState = useState(null),\n      instance = _React$useState[0],\n      setInstance = _React$useState[1];\n\n  useEffect(function effect() {\n    if (map !== null) {\n      if (instance === null) {\n        var positionLatLng;\n\n        if (position && !(position instanceof google.maps.LatLng)) {\n          positionLatLng = new google.maps.LatLng(position.lat, position.lng);\n        }\n\n        containerElementRef.current = document.createElement('div');\n        var infoBox = new InfoBox$1(_extends({}, infoBoxOptions, {}, positionLatLng ? {\n          position: positionLatLng\n        } : {}));\n        setInstance(infoBox);\n      }\n\n      if (instance !== null && containerElementRef.current !== null) {\n        instance.setContent(containerElementRef.current);\n\n        if (anchor) {\n          instance.open(map, anchor);\n        } else if (instance.getPosition()) {\n          instance.open(map);\n        } else {\n          process.env.NODE_ENV !== \"production\" ? invariant(false, 'You must provide either an anchor or a position prop for <InfoBox>.') : invariant(false);\n        }\n\n        if (onLoad) {\n          onLoad(instance);\n        }\n      }\n    }\n\n    return function cleanup() {\n      if (instance !== null) {\n        if (onUnmount) {\n          onUnmount(instance);\n        }\n\n        instance.close();\n      }\n    };\n  }, [instance, map, options, onLoad, onUnmount, anchor, containerElementRef, infoBoxOptions, position]);\n  useEffect(function effect() {\n    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$5,\n      eventMap: eventMap$5,\n      prevProps: prevProps,\n      nextProps: props,\n      instance: instance\n    });\n    return function cleanup() {\n      unregisterEvents(registeredEvents);\n    };\n  }, [props, instance, prevProps]);\n\n  if (containerElementRef.current === null) {\n    return createElement(Fragment, null);\n  } else {\n    return createElement(Fragment, null, createPortal(Children.only(children), containerElementRef.current));\n  }\n}\n\nvar InfoBox = /*#__PURE__*/memo(InfoBoxComponent);\nvar eventMap$6 = {\n  onCloseClick: 'closeclick',\n  onContentChanged: 'content_changed',\n  onDomReady: 'domready',\n  onPositionChanged: 'position_changed',\n  onZindexChanged: 'zindex_changed'\n};\nvar updaterMap$6 = {\n  options: function options(instance, _options) {\n    instance.setOptions(_options);\n  },\n  position: function position(instance, _position) {\n    instance.setPosition(_position);\n  },\n  zIndex: function zIndex(instance, _zIndex) {\n    instance.setZIndex(_zIndex);\n  }\n};\n\nfunction InfoWindow(props) {\n  var children = props.children,\n      anchor = props.anchor,\n      options = props.options,\n      onLoad = props.onLoad,\n      onUnmount = props.onUnmount;\n  var map = useContext(MapContext);\n  var prevProps = usePrevious(props);\n\n  var _React$useState = useState(null),\n      containerElement = _React$useState[0],\n      setContainerElement = _React$useState[1];\n\n  var _React$useState2 = useState(null),\n      instance = _React$useState2[0],\n      setInstance = _React$useState2[1];\n\n  useEffect(function effect() {\n    if (map !== null) {\n      if (instance === null) {\n        setInstance(new google.maps.InfoWindow(_extends({}, options || {})));\n        setContainerElement(document.createElement('div'));\n      }\n\n      if (instance !== null && containerElement !== null) {\n        instance.setContent(containerElement);\n\n        if (anchor) {\n          instance.open(map, anchor);\n        } else if (instance.getPosition()) {\n          instance.open(map);\n        } else {\n          process.env.NODE_ENV !== \"production\" ? invariant(false, \"You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.\") : invariant(false);\n        }\n\n        if (onLoad) {\n          onLoad(instance);\n        }\n      }\n    }\n\n    return function cleanup() {\n      if (instance !== null) {\n        if (onUnmount) {\n          onUnmount(instance);\n        }\n\n        instance.close();\n      }\n    };\n  }, [instance, anchor, containerElement, map, options, onLoad, onUnmount]);\n  useEffect(function effect() {\n    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$6,\n      eventMap: eventMap$6,\n      prevProps: prevProps,\n      nextProps: props,\n      instance: instance\n    });\n    return function cleanup() {\n      unregisterEvents(registeredEvents);\n    };\n  }, [props, instance, prevProps]);\n  return containerElement ? createElement(Fragment, null, createPortal(Children.only(children), containerElement)) : createElement(Fragment, null);\n}\n\nvar InfoWindow$1 = /*#__PURE__*/memo(InfoWindow);\nvar eventMap$7 = {\n  onClick: 'click',\n  onDblClick: 'dblclick',\n  onDrag: 'drag',\n  onDragEnd: 'dragend',\n  onDragStart: 'dragstart',\n  onMouseDown: 'mousedown',\n  onMouseMove: 'mousemove',\n  onMouseOut: 'mouseout',\n  onMouseOver: 'mouseover',\n  onMouseUp: 'mouseup',\n  onRightClick: 'rightclick'\n};\nvar updaterMap$7 = {\n  draggable: function draggable(instance, _draggable) {\n    instance.setDraggable(_draggable);\n  },\n  editable: function editable(instance, _editable) {\n    instance.setEditable(_editable);\n  },\n  map: function map(instance, _map) {\n    instance.setMap(_map);\n  },\n  options: function options(instance, _options) {\n    instance.setOptions(_options);\n  },\n  path: function path(instance, _path) {\n    instance.setPath(_path);\n  },\n  visible: function visible(instance, _visible) {\n    instance.setVisible(_visible);\n  }\n};\n\nfunction Polyline(props) {\n  var options = props.options,\n      onLoad = props.onLoad,\n      onUnmount = props.onUnmount;\n  var map = useContext(MapContext);\n  var prevProps = usePrevious(props);\n\n  var _React$useState = useState(null),\n      instance = _React$useState[0],\n      setInstance = _React$useState[1];\n\n  useEffect(function effect() {\n    if (map !== null) {\n      if (instance === null) {\n        setInstance(new google.maps.Polyline(_extends({}, options || {}, {\n          map: map\n        })));\n      }\n\n      if (instance !== null) {\n        instance.setMap(map);\n\n        if (onLoad) {\n          onLoad(instance);\n        }\n      }\n    }\n\n    return function cleanup() {\n      if (instance !== null) {\n        if (onUnmount) {\n          onUnmount(instance);\n        }\n\n        instance.setMap(null);\n      }\n    };\n  }, [instance, map, options, onLoad, onUnmount]);\n  useEffect(function effect() {\n    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$7,\n      eventMap: eventMap$7,\n      prevProps: prevProps,\n      nextProps: props,\n      instance: instance\n    });\n    return function cleanup() {\n      unregisterEvents(registeredEvents);\n    };\n  }, [props, instance, prevProps]);\n  return createElement(Fragment, null);\n}\n\nvar Polyline$1 = /*#__PURE__*/memo(Polyline);\nvar eventMap$8 = {\n  onClick: 'click',\n  onDblClick: 'dblclick',\n  onDrag: 'drag',\n  onDragEnd: 'dragend',\n  onDragStart: 'dragstart',\n  onMouseDown: 'mousedown',\n  onMouseMove: 'mousemove',\n  onMouseOut: 'mouseout',\n  onMouseOver: 'mouseover',\n  onMouseUp: 'mouseup',\n  onRightClick: 'rightclick'\n};\nvar updaterMap$8 = {\n  draggable: function draggable(instance, _draggable) {\n    instance.setDraggable(_draggable);\n  },\n  editable: function editable(instance, _editable) {\n    instance.setEditable(_editable);\n  },\n  map: function map(instance, _map) {\n    instance.setMap(_map);\n  },\n  options: function options(instance, _options) {\n    instance.setOptions(_options);\n  },\n  path: function path(instance, _path) {\n    instance.setPath(_path);\n  },\n  paths: function paths(instance, _paths) {\n    instance.setPaths(_paths);\n  },\n  visible: function visible(instance, _visible) {\n    instance.setVisible(_visible);\n  }\n};\n\nfunction Polygon(props) {\n  var options = props.options,\n      onLoad = props.onLoad,\n      onUnmount = props.onUnmount;\n  var map = useContext(MapContext);\n  var prevProps = usePrevious(props);\n\n  var _React$useState = useState(null),\n      instance = _React$useState[0],\n      setInstance = _React$useState[1];\n\n  useEffect(function effect() {\n    if (map !== null) {\n      if (instance === null) {\n        setInstance(new google.maps.Polygon(_extends({}, options || {}, {\n          map: map\n        })));\n      }\n\n      if (instance !== null) {\n        instance.setMap(map);\n\n        if (onLoad) {\n          onLoad(instance);\n        }\n      }\n    }\n\n    return function cleanup() {\n      if (instance !== null) {\n        if (onUnmount) {\n          onUnmount(instance);\n        }\n\n        instance.setMap(null);\n      }\n    };\n  }, [instance, map, options, onLoad, onUnmount]);\n  useEffect(function effect() {\n    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$8,\n      eventMap: eventMap$8,\n      prevProps: prevProps,\n      nextProps: props,\n      instance: instance\n    });\n    return function cleanup() {\n      unregisterEvents(registeredEvents);\n    };\n  }, [props, instance, prevProps]);\n  return createElement(Fragment, null);\n}\n\nvar Polygon$1 = /*#__PURE__*/memo(Polygon);\nvar eventMap$9 = {\n  onBoundsChanged: 'bounds_changed',\n  onClick: 'click',\n  onDblClick: 'dblclick',\n  onDrag: 'drag',\n  onDragEnd: 'dragend',\n  onDragStart: 'dragstart',\n  onMouseDown: 'mousedown',\n  onMouseMove: 'mousemove',\n  onMouseOut: 'mouseout',\n  onMouseOver: 'mouseover',\n  onMouseUp: 'mouseup',\n  onRightClick: 'rightclick'\n};\nvar updaterMap$9 = {\n  bounds: function bounds(instance, _bounds) {\n    instance.setBounds(_bounds);\n  },\n  draggable: function draggable(instance, _draggable) {\n    instance.setDraggable(_draggable);\n  },\n  editable: function editable(instance, _editable) {\n    instance.setEditable(_editable);\n  },\n  map: function map(instance, _map) {\n    instance.setMap(_map);\n  },\n  options: function options(instance, _options) {\n    instance.setOptions(_options);\n  },\n  visible: function visible(instance, _visible) {\n    instance.setVisible(_visible);\n  }\n};\n\nfunction Rectangle(props) {\n  var options = props.options,\n      onLoad = props.onLoad,\n      onUnmount = props.onUnmount;\n  var map = useContext(MapContext);\n  var prevProps = usePrevious(props);\n\n  var _React$useState = useState(null),\n      instance = _React$useState[0],\n      setInstance = _React$useState[1];\n\n  useEffect(function effect() {\n    if (map !== null) {\n      if (instance === null) {\n        setInstance(new google.maps.Rectangle(_extends({}, options || {}, {\n          map: map\n        })));\n      }\n\n      if (instance !== null) {\n        instance.setMap(map);\n\n        if (onLoad) {\n          onLoad(instance);\n        }\n      }\n    }\n\n    return function cleanup() {\n      if (instance !== null) {\n        if (onUnmount) {\n          onUnmount(instance);\n        }\n\n        instance.setMap(null);\n      }\n    };\n  }, [instance, map, options, onLoad, onUnmount]);\n  useEffect(function effect() {\n    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$9,\n      eventMap: eventMap$9,\n      prevProps: prevProps,\n      nextProps: props,\n      instance: instance\n    });\n    return function cleanup() {\n      unregisterEvents(registeredEvents);\n    };\n  }, [props, instance, prevProps]);\n  return createElement(Fragment, null);\n}\n\nvar Rectangle$1 = /*#__PURE__*/memo(Rectangle);\nvar eventMap$a = {\n  onCenterChanged: 'center_changed',\n  onClick: 'click',\n  onDblClick: 'dblclick',\n  onDrag: 'drag',\n  onDragEnd: 'dragend',\n  onDragStart: 'dragstart',\n  onMouseDown: 'mousedown',\n  onMouseMove: 'mousemove',\n  onMouseOut: 'mouseout',\n  onMouseOver: 'mouseover',\n  onMouseUp: 'mouseup',\n  onRadiusChanged: 'radius_changed',\n  onRightClick: 'rightclick'\n};\nvar updaterMap$a = {\n  center: function center(instance, _center) {\n    instance.setCenter(_center);\n  },\n  draggable: function draggable(instance, _draggable) {\n    instance.setDraggable(_draggable);\n  },\n  editable: function editable(instance, _editable) {\n    instance.setEditable(_editable);\n  },\n  map: function map(instance, _map) {\n    instance.setMap(_map);\n  },\n  options: function options(instance, _options) {\n    instance.setOptions(_options);\n  },\n  radius: function radius(instance, _radius) {\n    instance.setRadius(_radius);\n  },\n  visible: function visible(instance, _visible) {\n    instance.setVisible(_visible);\n  }\n};\n\nfunction Circle(props) {\n  var options = props.options,\n      onLoad = props.onLoad,\n      onUnmount = props.onUnmount;\n  var map = useContext(MapContext);\n  var prevProps = usePrevious(props);\n\n  var _React$useState = useState(null),\n      instance = _React$useState[0],\n      setInstance = _React$useState[1];\n\n  useEffect(function effect() {\n    if (map !== null) {\n      if (instance === null) {\n        setInstance(new google.maps.Circle(_extends({}, options || {}, {\n          map: map\n        })));\n      }\n\n      if (instance !== null) {\n        instance.setMap(map);\n\n        if (onLoad) {\n          onLoad(instance);\n        }\n      }\n    }\n\n    return function cleanup() {\n      if (instance !== null) {\n        if (onUnmount) {\n          onUnmount(instance);\n        }\n\n        instance.setMap(null);\n      }\n    };\n  }, [instance, map, options, onLoad, onUnmount]);\n  useEffect(function effect() {\n    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$a,\n      eventMap: eventMap$a,\n      prevProps: prevProps,\n      nextProps: props,\n      instance: instance\n    });\n    return function cleanup() {\n      unregisterEvents(registeredEvents);\n    };\n  }, [props, instance, prevProps]);\n  return createElement(Fragment, null);\n}\n\nvar Circle$1 = /*#__PURE__*/memo(Circle);\nvar eventMap$b = {\n  onAddFeature: 'addfeature',\n  onClick: 'click',\n  onDblClick: 'dblclick',\n  onMouseDown: 'mousedown',\n  onMouseOut: 'mouseout',\n  onMouseOver: 'mouseover',\n  onMouseUp: 'mouseup',\n  onRemoveFeature: 'removefeature',\n  onRemoveProperty: 'removeproperty',\n  onRightClick: 'rightclick',\n  onSetGeometry: 'setgeometry',\n  onSetProperty: 'setproperty'\n};\nvar updaterMap$b = {\n  add: function add(instance, features) {\n    instance.add(features);\n  },\n  addgeojson: function addgeojson(instance, geojson, options) {\n    instance.addGeoJson(geojson, options);\n  },\n  contains: function contains(instance, feature) {\n    instance.contains(feature);\n  },\n  foreach: function foreach(instance, callback) {\n    instance.forEach(callback);\n  },\n  loadgeojson: function loadgeojson(instance, url, options, callback) {\n    instance.loadGeoJson(url, options, callback);\n  },\n  overridestyle: function overridestyle(instance, feature, style) {\n    instance.overrideStyle(feature, style);\n  },\n  remove: function remove(instance, feature) {\n    instance.remove(feature);\n  },\n  revertstyle: function revertstyle(instance, feature) {\n    instance.revertStyle(feature);\n  },\n  controlposition: function controlposition(instance, controlPosition) {\n    instance.setControlPosition(controlPosition);\n  },\n  controls: function controls(instance, _controls) {\n    instance.setControls(_controls);\n  },\n  drawingmode: function drawingmode(instance, mode) {\n    instance.setDrawingMode(mode);\n  },\n  map: function map(instance, _map) {\n    instance.setMap(_map);\n  },\n  style: function style(instance, _style) {\n    instance.setStyle(_style);\n  },\n  togeojson: function togeojson(instance, // wait till @types/googlemapsapi support typescript 3.9.5\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  callback) {\n    instance.toGeoJson(callback);\n  }\n};\n\nfunction Data(props) {\n  var options = props.options,\n      onLoad = props.onLoad,\n      onUnmount = props.onUnmount;\n  var map = useContext(MapContext);\n  var prevProps = usePrevious(props);\n\n  var _React$useState = useState(null),\n      instance = _React$useState[0],\n      setInstance = _React$useState[1];\n\n  useEffect(function effect() {\n    if (map !== null) {\n      if (instance === null) {\n        setInstance(new google.maps.Data(_extends({}, options || {}, {\n          map: map\n        })));\n      }\n\n      if (instance !== null) {\n        instance.setMap(map);\n\n        if (onLoad) {\n          onLoad(instance);\n        }\n      }\n    }\n\n    return function cleanup() {\n      if (instance !== null) {\n        if (onUnmount) {\n          onUnmount(instance);\n        }\n\n        instance.setMap(null);\n      }\n    };\n  }, [instance, map, options, onLoad, onUnmount]);\n  useEffect(function effect() {\n    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$b,\n      eventMap: eventMap$b,\n      prevProps: prevProps,\n      nextProps: props,\n      instance: instance\n    });\n    return function cleanup() {\n      unregisterEvents(registeredEvents);\n    };\n  }, [props, instance, prevProps]);\n  return createElement(Fragment, null);\n}\n\nvar Data$1 = /*#__PURE__*/memo(Data);\nvar eventMap$c = {\n  onClick: 'click',\n  onDefaultViewportChanged: 'defaultviewport_changed',\n  onStatusChanged: 'status_changed'\n};\nvar updaterMap$c = {\n  options: function options(instance, _options) {\n    instance.setOptions(_options);\n  },\n  url: function url(instance, _url) {\n    instance.setUrl(_url);\n  },\n  zIndex: function zIndex(instance, _zIndex) {\n    instance.setZIndex(_zIndex);\n  }\n};\n\nfunction KmlLayer(props) {\n  var options = props.options,\n      onLoad = props.onLoad,\n      onUnmount = props.onUnmount;\n  var map = useContext(MapContext);\n  var prevProps = usePrevious(props);\n\n  var _React$useState = useState(null),\n      instance = _React$useState[0],\n      setInstance = _React$useState[1];\n\n  useEffect(function effect() {\n    if (map !== null) {\n      if (instance === null) {\n        setInstance(new google.maps.KmlLayer(_extends({}, options || {}, {\n          map: map\n        })));\n      }\n\n      if (instance !== null) {\n        instance.setMap(map);\n\n        if (onLoad) {\n          onLoad(instance);\n        }\n      }\n    }\n\n    return function cleanup() {\n      if (instance !== null) {\n        if (onUnmount) {\n          onUnmount(instance);\n        }\n\n        instance.setMap(null);\n      }\n    };\n  }, [instance, map, options, onLoad, onUnmount]);\n  useEffect(function effect() {\n    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$c,\n      eventMap: eventMap$c,\n      prevProps: prevProps,\n      nextProps: props,\n      instance: instance\n    });\n    return function cleanup() {\n      unregisterEvents(registeredEvents);\n    };\n  }, [props, instance, prevProps]);\n  return createElement(Fragment, null);\n}\n\nvar KmlLayer$1 = /*#__PURE__*/memo(KmlLayer);\n\nfunction ContentMountHandler(_ref) {\n  var children = _ref.children,\n      onLoad = _ref.onLoad;\n  useEffect(function effect() {\n    if (onLoad) {\n      onLoad();\n    }\n  }, [onLoad]);\n  return createElement(Fragment, null, children);\n}\n\nvar ContentMountHandler$1 = /*#__PURE__*/memo(ContentMountHandler);\n\nfunction getOffsetOverride(containerElement, getPixelPositionOffset) {\n  return typeof getPixelPositionOffset === 'function' ? getPixelPositionOffset(containerElement.offsetWidth, containerElement.offsetHeight) : {};\n} // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nfunction createLatLng(inst, Type) {\n  return new Type(inst.lat, inst.lng);\n} // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nfunction createLatLngBounds(inst, Type) {\n  return new Type(new google.maps.LatLng(inst.ne.lat, inst.ne.lng), new google.maps.LatLng(inst.sw.lat, inst.sw.lng));\n}\n\nfunction ensureOfType(inst, // eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype, // eslint-disable-next-line @typescript-eslint/no-explicit-any\nfactory // eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n  return inst instanceof type ? inst : factory(inst, type);\n}\n\nvar getLayoutStylesByBounds = function getLayoutStylesByBounds(mapCanvasProjection, offset, bounds) {\n  var ne = mapCanvasProjection.fromLatLngToDivPixel(bounds.getNorthEast());\n  var sw = mapCanvasProjection.fromLatLngToDivPixel(bounds.getSouthWest());\n\n  if (ne && sw) {\n    return {\n      left: sw.x + offset.x + \"px\",\n      top: ne.y + offset.y + \"px\",\n      width: ne.x - sw.x - offset.x + \"px\",\n      height: sw.y - ne.y - offset.y + \"px\"\n    };\n  }\n\n  return {\n    left: '-9999px',\n    top: '-9999px'\n  };\n};\n\nfunction getLayoutStylesByPosition(mapCanvasProjection, offset, position) {\n  var point = mapCanvasProjection.fromLatLngToDivPixel(position);\n\n  if (point) {\n    var x = point.x,\n        y = point.y;\n    return {\n      left: x + offset.x + \"px\",\n      top: y + offset.y + \"px\"\n    };\n  }\n\n  return {\n    left: '-9999px',\n    top: '-9999px'\n  };\n}\n\nfunction getLayoutStyles(mapCanvasProjection, offset, bounds, position) {\n  if (bounds !== undefined) {\n    return getLayoutStylesByBounds(mapCanvasProjection, offset, ensureOfType(bounds, google.maps.LatLngBounds, createLatLngBounds));\n  }\n\n  if (position !== undefined) {\n    return getLayoutStylesByPosition(mapCanvasProjection, offset, ensureOfType(position, google.maps.LatLng, createLatLng));\n  }\n\n  return null;\n}\n\nfunction convertToLatLngString(latLngLike) {\n  if (!latLngLike) {\n    return '';\n  }\n\n  var latLng = latLngLike instanceof google.maps.LatLng ? latLngLike : new google.maps.LatLng(latLngLike.lat, latLngLike.lng);\n  return latLng + '';\n}\n\nfunction convertToLatLngBoundsString(latLngBoundsLike) {\n  if (!latLngBoundsLike) {\n    return '';\n  }\n\n  var latLngBounds = latLngBoundsLike instanceof google.maps.LatLngBounds ? latLngBoundsLike : new google.maps.LatLngBounds(new google.maps.LatLng(latLngBoundsLike.south, latLngBoundsLike.east), new google.maps.LatLng(latLngBoundsLike.north, latLngBoundsLike.west));\n  return latLngBounds + '';\n} // const FLOAT_PANE = `floatPane`\n// const MAP_PANE = `mapPane`\n// const MARKER_LAYER = `markerLayer`\n// const OVERLAY_LAYER = `overlayLayer`\n// const OVERLAY_MOUSE_TARGET = `overlayMouseTarget`\n\n\nfunction OverlayView(props) {\n  var children = props.children,\n      mapPaneName = props.mapPaneName,\n      bounds = props.bounds,\n      getPixelPositionOffset = props.getPixelPositionOffset,\n      onLoad = props.onLoad,\n      onUnmount = props.onUnmount,\n      position = props.position;\n  var prevProps = usePrevious(props);\n  var map = useContext(MapContext);\n\n  var _React$useState = useState(null),\n      instance = _React$useState[0],\n      setInstance = _React$useState[1];\n\n  var _React$useState2 = useState(null),\n      containerStyle = _React$useState2[0],\n      setContainerStyle = _React$useState2[1];\n\n  var mapPanelRef = useRef(null);\n  var containerRef = useRef(null);\n  var onPositionElement = useCallback(function callback() {\n    if (instance !== null) {\n      var mapCanvasProjection = instance.getProjection();\n\n      var offset = _extends({\n        x: 0,\n        y: 0\n      }, containerRef.current ? getOffsetOverride(containerRef.current, getPixelPositionOffset) : {});\n\n      var layoutStyles = getLayoutStyles(mapCanvasProjection, offset, bounds, position);\n      setContainerStyle(layoutStyles);\n    }\n  }, [bounds, getPixelPositionOffset, instance, position]);\n  var draw = useCallback(function callback() {\n    onPositionElement();\n  }, [onPositionElement]);\n  var onRemove = useCallback(function callback() {\n    mapPanelRef.current = null;\n  }, []);\n  var handleOverlayViewCallback = useCallback(function callback() {\n    if (instance !== null && onLoad) {\n      onLoad(instance);\n    }\n\n    onPositionElement();\n  }, [instance, onLoad, onPositionElement]);\n  var onAdd = useCallback(function callback() {\n    !!!mapPaneName ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"OverlayView requires mapPaneName but got %s\", mapPaneName) : invariant(false) : void 0; // https://developers.google.com/maps/documentation/javascript/3.exp/reference#MapPanes\n\n    if (instance !== null) {\n      var mapPanes = instance.getPanes();\n\n      if (!mapPanes) {\n        return;\n      }\n\n      mapPanelRef.current = mapPanes[mapPaneName];\n    }\n  }, [instance, mapPaneName]);\n  useEffect(function effect() {\n    var instance = new google.maps.OverlayView(); // You must implement three methods: onAdd(), draw(), and onRemove().\n\n    instance.onAdd = onAdd;\n    instance.draw = draw;\n    instance.onRemove = onRemove; // the onAdd() method and setMap(null) in order to trigger the onRemove() method.\n    // You must call setMap() with a valid Map object to trigger the call to\n\n    instance.setMap(map);\n    setInstance(instance);\n    return function cleanup() {\n      if (instance !== null) {\n        if (onUnmount) {\n          onUnmount(instance);\n        }\n\n        instance.setMap(null);\n      }\n    };\n  }, [draw, map, onAdd, onRemove, onUnmount]);\n  useEffect(function effect() {\n    var prevPositionString = convertToLatLngString(prevProps.position);\n    var positionString = convertToLatLngString(position);\n    var prevBoundsString = convertToLatLngBoundsString(prevProps.bounds);\n    var boundsString = convertToLatLngBoundsString(bounds);\n    var timeout = 0;\n\n    if (prevPositionString !== positionString || prevBoundsString !== boundsString) {\n      timeout = window.setTimeout(function () {\n        instance !== null && instance.draw();\n      }, 0);\n    }\n\n    return function cleanup() {\n      window.clearTimeout(timeout);\n    };\n  }, [bounds, instance, position, prevProps.bounds, prevProps.position]);\n  var containerStyleMemo = useMemo(function memo() {\n    return _extends({}, containerStyle, {\n      position: 'absolute'\n    });\n  }, [containerStyle]);\n  return mapPanelRef.current !== null ? createPortal(createElement(\"div\", {\n    ref: containerRef,\n    style: containerStyleMemo\n  }, createElement(ContentMountHandler$1, {\n    onLoad: handleOverlayViewCallback\n  }, Children.only(children))), mapPanelRef.current) : createElement(Fragment, null);\n}\n\nvar OverlayView$1 = /*#__PURE__*/memo(OverlayView);\n\nfunction noop() {\n  return;\n}\n\nvar eventMap$d = {\n  onDblClick: 'dblclick',\n  onClick: 'click'\n};\nvar updaterMap$d = {\n  opacity: function opacity(instance, _opacity) {\n    instance.setOpacity(_opacity);\n  }\n};\n\nfunction GroundOverlay(props) {\n  var options = props.options,\n      url = props.url,\n      bounds = props.bounds,\n      _props$onLoad = props.onLoad,\n      onLoad = _props$onLoad === void 0 ? noop : _props$onLoad,\n      onUnmount = props.onUnmount;\n  var map = useContext(MapContext);\n  var prevProps = usePrevious(props);\n\n  var _React$useState = useState(null),\n      instance = _React$useState[0],\n      setInstance = _React$useState[1];\n\n  useEffect(function effect() {\n    !(!!url || !!bounds) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655\") : invariant(false) : void 0;\n\n    if (map !== null) {\n      if (instance === null) {\n        setInstance(new google.maps.GroundOverlay(url, bounds, _extends({}, options || {}, {\n          map: map\n        })));\n      }\n\n      if (instance !== null) {\n        instance.setMap(map);\n\n        if (onLoad) {\n          onLoad(instance);\n        }\n      }\n    }\n\n    return function cleanup() {\n      if (instance !== null) {\n        if (onUnmount) {\n          onUnmount(instance);\n        }\n\n        instance.setMap(null);\n      }\n    };\n  }, [instance, map, bounds, url, options, onLoad, onUnmount]);\n  useEffect(function effect() {\n    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$d,\n      eventMap: eventMap$d,\n      prevProps: prevProps,\n      nextProps: props,\n      instance: instance\n    });\n    return function cleanup() {\n      unregisterEvents(registeredEvents);\n    };\n  }, [props, instance, prevProps]);\n  return createElement(Fragment, null);\n}\n\nvar GroundOverlay$1 = /*#__PURE__*/memo(GroundOverlay);\nvar eventMap$e = {};\nvar updaterMap$e = {\n  data: function data(instance, _data) {\n    instance.setData(_data);\n  },\n  map: function map(instance, _map) {\n    instance.setMap(_map);\n  },\n  options: function options(instance, _options) {\n    instance.setOptions(_options);\n  }\n};\n\nfunction HeatmapLayer(props) {\n  var data = props.data,\n      options = props.options,\n      onLoad = props.onLoad,\n      onUnmount = props.onUnmount;\n  var map = useContext(MapContext);\n  var prevProps = usePrevious(props);\n\n  var _React$useState = useState(null),\n      instance = _React$useState[0],\n      setInstance = _React$useState[1];\n\n  useEffect(function effect() {\n    !!!google.maps.visualization ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Did you include prop libraries={[\"visualization\"]} to <LoadScript />? %s', google.maps.visualization) : invariant(false) : void 0;\n    !!!data ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'data property is required in HeatmapLayer %s', data) : invariant(false) : void 0;\n\n    if (map !== null) {\n      if (instance === null) {\n        setInstance(new google.maps.visualization.HeatmapLayer(_extends({}, options || {}, {\n          data: data,\n          map: map\n        })));\n      }\n\n      if (instance !== null) {\n        instance.setMap(map);\n\n        if (onLoad) {\n          onLoad(instance);\n        }\n      }\n    }\n\n    return function cleanup() {\n      if (instance !== null) {\n        if (onUnmount) {\n          onUnmount(instance);\n        }\n\n        instance.setMap(null);\n      }\n    };\n  }, [instance, data, map, options, onLoad, onUnmount]);\n  useEffect(function effect() {\n    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$e,\n      eventMap: eventMap$e,\n      prevProps: prevProps,\n      nextProps: props,\n      instance: instance\n    });\n    return function cleanup() {\n      unregisterEvents(registeredEvents);\n    };\n  }, [props, instance, prevProps]);\n  return createElement(Fragment, null);\n}\n\nvar HeatmapLayer$1 = /*#__PURE__*/memo(HeatmapLayer);\nvar eventMap$f = {\n  onCloseClick: 'closeclick',\n  onPanoChanged: 'pano_changed',\n  onPositionChanged: 'position_changed',\n  onPovChanged: 'pov_changed',\n  onResize: 'resize',\n  onStatusChanged: 'status_changed',\n  onVisibleChanged: 'visible_changed',\n  onZoomChanged: 'zoom_changed'\n};\nvar updaterMap$f = {\n  register: function register(instance, provider, options) {\n    instance.registerPanoProvider(provider, options);\n  },\n  links: function links(instance, _links) {\n    instance.setLinks(_links);\n  },\n  motionTracking: function motionTracking(instance, _motionTracking) {\n    instance.setMotionTracking(_motionTracking);\n  },\n  options: function options(instance, _options) {\n    instance.setOptions(_options);\n  },\n  pano: function pano(instance, _pano) {\n    instance.setPano(_pano);\n  },\n  position: function position(instance, _position) {\n    instance.setPosition(_position);\n  },\n  pov: function pov(instance, _pov) {\n    instance.setPov(_pov);\n  },\n  visible: function visible(instance, _visible) {\n    instance.setVisible(_visible);\n  },\n  zoom: function zoom(instance, _zoom) {\n    instance.setZoom(_zoom);\n  }\n};\n\nfunction StreetViewPanorama(props) {\n  var options = props.options,\n      onLoad = props.onLoad,\n      onUnmount = props.onUnmount;\n  var map = useContext(MapContext);\n  var prevProps = usePrevious(props);\n\n  var _React$useState = useState(null),\n      instance = _React$useState[0],\n      setInstance = _React$useState[1];\n\n  useEffect(function effect() {\n    if (map !== null) {\n      if (instance === null) {\n        setInstance(map.getStreetView());\n      }\n\n      if (instance !== null) {\n        if (onLoad) {\n          onLoad(instance);\n        }\n      }\n    }\n\n    return function cleanup() {\n      if (instance !== null) {\n        if (onUnmount) {\n          onUnmount(instance);\n        }\n\n        instance.setVisible(false);\n      }\n    };\n  }, [instance, map, options, onLoad, onUnmount]);\n  useEffect(function effect() {\n    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$f,\n      eventMap: eventMap$f,\n      prevProps: prevProps,\n      nextProps: props,\n      instance: instance\n    });\n    return function cleanup() {\n      unregisterEvents(registeredEvents);\n    };\n  }, [props, instance, prevProps]);\n  return createElement(Fragment, null);\n}\n\nfunction StreetViewService(props) {\n  var onLoad = props.onLoad,\n      onUnmount = props.onUnmount;\n\n  var _React$useState = useState(null),\n      instance = _React$useState[0],\n      setInstance = _React$useState[1];\n\n  useEffect(function effect() {\n    var streetViewService = new google.maps.StreetViewService();\n    setInstance(streetViewService);\n\n    if (instance !== null && onLoad) {\n      onLoad(instance);\n    }\n\n    return function callback() {\n      if (instance !== null) {\n        if (onUnmount) {\n          onUnmount(instance);\n        }\n      }\n    };\n  }, [instance, onLoad, onUnmount]);\n  return createElement(Fragment, null);\n}\n\nvar StreetViewService$1 = /*#__PURE__*/memo(StreetViewService);\n\nfunction DirectionsService(props) {\n  var options = props.options,\n      callback = props.callback,\n      onLoad = props.onLoad,\n      onUnmount = props.onUnmount;\n\n  var _React$useState = useState(null),\n      instance = _React$useState[0],\n      setInstance = _React$useState[1];\n\n  useEffect(function effect() {\n    !!!options ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DirectionsService expected options object as parameter, but got %s', options) : invariant(false) : void 0;\n\n    if (instance === null) {\n      setInstance(new google.maps.DirectionsService());\n    }\n\n    if (instance !== null) {\n      if (onLoad) {\n        onLoad(instance);\n      }\n    }\n\n    return function cleanup() {\n      if (instance !== null) {\n        if (onUnmount) {\n          onUnmount(instance);\n        }\n      }\n    };\n  }, [instance, options, onLoad, onUnmount]);\n  useEffect(function effect() {\n    if (instance !== null) {\n      instance.route(options, callback);\n    }\n  }, [instance, options, callback]);\n  return createElement(Fragment, null);\n}\n\nvar DirectionsService$1 = /*#__PURE__*/memo(DirectionsService);\nvar eventMap$g = {\n  onDirectionsChanged: 'directions_changed'\n};\nvar updaterMap$g = {\n  directions: function directions(instance, _directions) {\n    instance.setDirections(_directions);\n  },\n  map: function map(instance, _map) {\n    instance.setMap(_map);\n  },\n  options: function options(instance, _options) {\n    instance.setOptions(_options);\n  },\n  panel: function panel(instance, _panel) {\n    instance.setPanel(_panel);\n  },\n  routeIndex: function routeIndex(instance, _routeIndex) {\n    instance.setRouteIndex(_routeIndex);\n  }\n};\n\nfunction DirectionsRenderer(props) {\n  var options = props.options,\n      onLoad = props.onLoad,\n      onUnmount = props.onUnmount;\n  var map = useContext(MapContext);\n  var prevProps = usePrevious(props);\n\n  var _React$useState = useState(null),\n      instance = _React$useState[0],\n      setInstance = _React$useState[1];\n\n  useEffect(function effect() {\n    if (map !== null) {\n      if (instance === null) {\n        setInstance(new google.maps.DirectionsRenderer(options));\n      }\n\n      if (instance !== null) {\n        instance.setMap(map);\n\n        if (onLoad) {\n          onLoad(instance);\n        }\n      }\n    }\n\n    return function cleanup() {\n      if (instance !== null) {\n        if (onUnmount) {\n          onUnmount(instance);\n        }\n\n        instance.setMap(null);\n      }\n    };\n  }, [instance, map, options, onLoad, onUnmount]);\n  useEffect(function effect() {\n    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$g,\n      eventMap: eventMap$g,\n      prevProps: prevProps,\n      nextProps: props,\n      instance: instance\n    });\n    return function cleanup() {\n      unregisterEvents(registeredEvents);\n    };\n  }, [props, instance, prevProps]);\n  return createElement(Fragment, null);\n}\n\nvar DirectionsRenderer$1 = /*#__PURE__*/memo(DirectionsRenderer);\n\nfunction DistanceMatrixService(props) {\n  var options = props.options,\n      callback = props.callback,\n      onLoad = props.onLoad,\n      onUnmount = props.onUnmount;\n\n  var _React$useState = useState(null),\n      instance = _React$useState[0],\n      setInstance = _React$useState[1];\n\n  useEffect(function effect() {\n    !!!options ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'DistanceMatrixService expected options object as parameter, but go %s', options) : invariant(false) : void 0;\n\n    if (instance === null) {\n      setInstance(new google.maps.DistanceMatrixService());\n    }\n\n    if (instance !== null) {\n      if (onLoad) {\n        onLoad(instance);\n      }\n    }\n\n    return function cleanup() {\n      if (instance !== null) {\n        if (onUnmount) {\n          onUnmount(instance);\n        }\n      }\n    };\n  }, [instance, options, onLoad, onUnmount]);\n  useEffect(function effect() {\n    if (instance !== null) {\n      instance.getDistanceMatrix(options, callback);\n    }\n  }, [instance, options, callback]);\n  return createElement(Fragment, null);\n}\n\nvar DistanceMatrixService$1 = /*#__PURE__*/memo(DistanceMatrixService);\nvar eventMap$h = {\n  onPlacesChanged: 'places_changed'\n};\nvar updaterMap$h = {\n  bounds: function bounds(instance, _bounds) {\n    instance.setBounds(_bounds);\n  }\n};\n\nfunction StandaloneSearchBox(props) {\n  var children = props.children,\n      options = props.options,\n      onLoad = props.onLoad,\n      onUnmount = props.onUnmount;\n  var map = useContext(MapContext);\n  var prevProps = usePrevious(props);\n  var containerElementRef = useRef(null);\n\n  var _React$useState = useState(null),\n      instance = _React$useState[0],\n      setInstance = _React$useState[1];\n\n  useEffect(function effect() {\n    !!!google.maps.places ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'You need to provide libraries={[\"places\"]} prop to <LoadScript /> component %s', google.maps.places) : invariant(false) : void 0;\n\n    if (map !== null) {\n      if (containerElementRef.current !== null) {\n        var input = containerElementRef.current.querySelector('input');\n\n        if (input !== null) {\n          var searchBox = new google.maps.places.SearchBox(input, options);\n          setInstance(searchBox);\n\n          if (searchBox !== null && onLoad) {\n            onLoad(searchBox);\n          }\n        }\n      }\n    }\n\n    return function cleanup() {\n      if (instance !== null) {\n        if (onUnmount) {\n          onUnmount(instance);\n        }\n      }\n    };\n  }, [instance, map, options, onLoad, onUnmount]);\n  useEffect(function effect() {\n    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$h,\n      eventMap: eventMap$h,\n      prevProps: prevProps,\n      nextProps: props,\n      instance: instance\n    });\n    return function cleanup() {\n      unregisterEvents(registeredEvents);\n    };\n  }, [props, instance, prevProps]);\n  return createElement(\"div\", {\n    ref: containerElementRef\n  }, Children.only(children));\n}\n\nvar StandaloneSearchBox$1 = /*#__PURE__*/memo(StandaloneSearchBox);\nvar eventMap$i = {\n  onPlaceChanged: 'place_changed'\n};\nvar updaterMap$i = {\n  bounds: function bounds(instance, _bounds) {\n    instance.setBounds(_bounds);\n  },\n  restrictions: function restrictions(instance, _restrictions) {\n    instance.setComponentRestrictions(_restrictions);\n  },\n  fields: function fields(instance, _fields) {\n    instance.setFields(_fields);\n  },\n  options: function options(instance, _options) {\n    instance.setOptions(_options);\n  },\n  types: function types(instance, _types) {\n    instance.setTypes(_types);\n  }\n};\n\nfunction Autocomplete(props) {\n  var children = props.children,\n      options = props.options,\n      onLoad = props.onLoad,\n      onUnmount = props.onUnmount;\n  var map = useContext(MapContext);\n  var prevProps = usePrevious(props);\n  var containerElementRef = useRef(null);\n\n  var _React$useState = useState(null),\n      instance = _React$useState[0],\n      setInstance = _React$useState[1];\n\n  useEffect(function effect() {\n    !!!google.maps.places ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'You need to provide libraries={[\"places\"]} prop to <LoadScript /> component %s', google.maps.places) : invariant(false) : void 0;\n\n    if (containerElementRef.current !== null) {\n      var input = containerElementRef.current.querySelector('input');\n\n      if (input) {\n        var autocomplete = new google.maps.places.Autocomplete(input, options);\n        setInstance(autocomplete);\n\n        if (onLoad) {\n          onLoad(autocomplete);\n        }\n      }\n    }\n\n    return function cleanup() {\n      if (instance !== null) {\n        if (onUnmount) {\n          onUnmount(instance);\n        }\n      }\n    };\n  }, [instance, map, options, onLoad, onUnmount]);\n  useEffect(function effect() {\n    var registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$i,\n      eventMap: eventMap$i,\n      prevProps: prevProps,\n      nextProps: props,\n      instance: instance\n    });\n    return function cleanup() {\n      unregisterEvents(registeredEvents);\n    };\n  }, [props, instance, prevProps]);\n  return createElement(\"div\", {\n    ref: containerElementRef\n  }, Children.only(children));\n}\n\nvar Autocomplete$1 = /*#__PURE__*/memo(Autocomplete);\nexport { Autocomplete$1 as Autocomplete, BicyclingLayer$1 as BicyclingLayer, Circle$1 as Circle, Data$1 as Data, DirectionsRenderer$1 as DirectionsRenderer, DirectionsService$1 as DirectionsService, DistanceMatrixService$1 as DistanceMatrixService, DrawingManager$1 as DrawingManager, GoogleMap$1 as GoogleMap, GroundOverlay$1 as GroundOverlay, HeatmapLayer$1 as HeatmapLayer, InfoBox, InfoWindow$1 as InfoWindow, KmlLayer$1 as KmlLayer, LoadScript$1 as LoadScript, LoadScriptNext$1 as LoadScriptNext, MapContext, Marker$1 as Marker, MarkerClusterer, OverlayView$1 as OverlayView, Polygon$1 as Polygon, Polyline$1 as Polyline, Rectangle$1 as Rectangle, StandaloneSearchBox$1 as StandaloneSearchBox, StreetViewPanorama, StreetViewService$1 as StreetViewService, TrafficLayer$1 as TrafficLayer, TransitLayer$1 as TransitLayer, useGoogleMap, useLoadScript };","map":null,"metadata":{},"sourceType":"module"}